{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/AutomationBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract AutomationBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/AutomationCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AutomationBase.sol\";\nimport \"./interfaces/AutomationCompatibleInterface.sol\";\n\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.0;\n\nimport {\n    ISuperfluid,\n    ISuperfluidToken\n} from \"../interfaces/superfluid/ISuperfluid.sol\";\n\nimport {\n    IConstantFlowAgreementV1\n} from \"../interfaces/agreements/IConstantFlowAgreementV1.sol\";\n\n/**\n * @title Constant flow agreement v1 library\n * @author Superfluid\n * @dev for working with the constant flow agreement within solidity\n * @dev the first set of functions are each for callAgreement()\n * @dev the second set of functions are each for use in callAgreementWithContext()\n */\nlibrary CFAv1Library {\n\n    /**\n     * @dev Initialization data\n     * @param host Superfluid host for calling agreements\n     * @param cfa Constant Flow Agreement contract\n     */\n    struct InitData {\n        ISuperfluid host;\n        IConstantFlowAgreementV1 cfa;\n    }\n\n    /**\n     * @dev Create flow without userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlow(\n        InitData storage cfaLibrary,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal {\n        createFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\n    }\n\n    /**\n     * @dev Create flow with userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function createFlow(\n        InitData storage cfaLibrary,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal {\n        cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.createFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData\n        );\n    }\n\n    /**\n     * @dev Update flow without userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlow(\n        InitData storage cfaLibrary,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal {\n        updateFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\n    }\n\n    /**\n     * @dev Update flow with userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function updateFlow(\n        InitData storage cfaLibrary,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal {\n        cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.updateFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData\n        );\n    }\n\n    /**\n     * @dev Delete flow without userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     */\n    function deleteFlow(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token\n    ) internal {\n        deleteFlow(cfaLibrary, sender, receiver, token, new bytes(0));\n    }\n\n    /**\n     * @dev Delete flow with userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param userData The user provided data\n     */\n    function deleteFlow(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        bytes memory userData\n    ) internal {\n        cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.deleteFlow,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData\n        );\n    }\n\n    /**\n     * @dev Create flow with context and userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlowWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal returns (bytes memory newCtx) {\n        return createFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\n    }\n\n    /**\n     * @dev Create flow with context and userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function createFlowWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.createFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData,\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update flow with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlowWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal returns (bytes memory newCtx) {\n        return updateFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\n    }\n\n    /**\n     * @dev Update flow with context and userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function updateFlowWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.updateFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData,\n            ctx\n        );\n    }\n\n    /**\n     * @dev Delete flow with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     */\n    function deleteFlowWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        return deleteFlowWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\n    }\n\n    /**\n     * @dev Delete flow with context and userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param userData The user provided data\n     */\n    function deleteFlowWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.deleteFlow,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData,\n            ctx\n        );\n    }\n\n    /**\n     * @dev Creates flow as an operator without userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlowByOperator(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal returns (bytes memory newCtx) {\n        return createFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\n    }\n\n    /**\n     * @dev Creates flow as an operator with userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function createFlowByOperator(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        return cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.createFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData\n        );\n    }\n\n    /**\n     * @dev Creates flow as an operator without userData with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlowByOperatorWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal returns (bytes memory newCtx) {\n        return createFlowByOperatorWithCtx(\n            cfaLibrary,\n            ctx,\n            sender,\n            receiver,\n            token,\n            flowRate,\n            new bytes(0)\n        );\n    }\n\n    /**\n     * @dev Creates flow as an operator with userData and context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function createFlowByOperatorWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.createFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            userData,\n            ctx\n        );\n    }\n\n    /**\n     * @dev Updates a flow as an operator without userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlowByOperator(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal returns (bytes memory newCtx) {\n        return updateFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\n    }\n\n    /**\n     * @dev Updates flow as an operator with userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function updateFlowByOperator(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        return cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.updateFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0)\n                )\n            ),\n            userData\n        );\n    }\n\n    /**\n     * @dev Updates a flow as an operator without userData with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlowByOperatorWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate\n    ) internal returns (bytes memory newCtx) {\n        return updateFlowByOperatorWithCtx(\n            cfaLibrary,\n            ctx,\n            sender,\n            receiver,\n            token,\n            flowRate,\n            new bytes(0)\n        );\n    }\n\n    /**\n     * @dev Updates flow as an operator with userData and context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function updateFlowByOperatorWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.updateFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0)\n                )\n            ),\n            userData,\n            ctx\n        );\n    }\n\n    /**\n     * @dev Deletes a flow as an operator without userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     */\n    function deleteFlowByOperator(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        return deleteFlowByOperator(cfaLibrary, sender, receiver, token, new bytes(0));\n    }\n\n    /**\n     * @dev Deletes a flow as an operator with userData\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param userData The user provided data\n     */\n    function deleteFlowByOperator(\n        InitData storage cfaLibrary,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        return cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.deleteFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0)\n                )\n            ),\n            userData\n        );\n    }\n\n    /**\n     * @dev Deletes a flow as an operator without userData with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     */\n    function deleteFlowByOperatorWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        return deleteFlowByOperatorWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\n    }\n\n    /**\n     * @dev Deletes a flow as an operator with userData and context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param token The token to flow\n     * @param userData The user provided data\n     */\n    function deleteFlowByOperatorWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address sender,\n        address receiver,\n        ISuperfluidToken token,\n        bytes memory userData\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.deleteFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0)\n                )\n            ),\n            userData,\n            ctx\n        );\n    }\n\n    /**\n     * @dev Updates the permissions of a flow operator\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param flowOperator The operator that can create/update/delete flows\n     * @param token The token of flows handled by the operator\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\n     */\n    function updateFlowOperatorPermissions(\n        InitData storage cfaLibrary,\n        address flowOperator,\n        ISuperfluidToken token,\n        uint8 permissions,\n        int96 flowRateAllowance\n    ) internal returns (bytes memory newCtx) {\n        return cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\n                (\n                    token,\n                    flowOperator,\n                    permissions,\n                    flowRateAllowance,\n                    new bytes(0)\n                )\n            ),\n            new bytes(0)\n        );\n    }\n\n    /**\n     * @dev Updates the permissions of a flow operator with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param flowOperator The operator that can create/update/delete flows\n     * @param token The token of flows handled by the operator\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\n     */\n    function updateFlowOperatorPermissionsWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address flowOperator,\n        ISuperfluidToken token,\n        uint8 permissions,\n        int96 flowRateAllowance\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\n                (\n                    token,\n                    flowOperator,\n                    permissions,\n                    flowRateAllowance,\n                    new bytes(0)\n                )\n            ),\n            new bytes(0),\n            ctx\n        );\n    }\n\n    /**\n     * @dev Grants full, unlimited permission to a flow operator\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param flowOperator The operator that can create/update/delete flows\n     * @param token The token of flows handled by the operator\n     */\n    function authorizeFlowOperatorWithFullControl(\n        InitData storage cfaLibrary,\n        address flowOperator,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        return cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\n                (\n                    token,\n                    flowOperator,\n                    new bytes(0)\n                )\n            ),\n            new bytes(0)\n        );\n    }\n\n    /**\n     * @dev Grants full, unlimited permission to a flow operator with context\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param flowOperator The operator that can create/update/delete flows\n     * @param token The token of flows handled by the operator\n     */\n    function authorizeFlowOperatorWithFullControlWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address flowOperator,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\n                (\n                    token,\n                    flowOperator,\n                    new bytes(0)\n                )\n            ),\n            new bytes(0),\n            ctx\n        );\n    }\n\n    /**\n     * @dev Revokes all permissions from a flow operator\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param flowOperator The operator that can create/update/delete flows\n     * @param token The token of flows handled by the operator\n     */\n    function revokeFlowOperatorWithFullControl(\n        InitData storage cfaLibrary,\n        address flowOperator,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        return cfaLibrary.host.callAgreement(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\n                (\n                    token,\n                    flowOperator,\n                    new bytes(0)\n                )\n            ),\n            new bytes(0)\n        );\n    }\n\n    /**\n     * @dev Revokes all permissions from a flow operator\n     * @param cfaLibrary The cfaLibrary storage variable\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param flowOperator The operator that can create/update/delete flows\n     * @param token The token of flows handled by the operator\n     */\n    function revokeFlowOperatorWithFullControlWithCtx(\n        InitData storage cfaLibrary,\n        bytes memory ctx,\n        address flowOperator,\n        ISuperfluidToken token\n    ) internal returns (bytes memory newCtx) {\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\n            cfaLibrary.cfa,\n            abi.encodeCall(\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\n                (\n                    token,\n                    flowOperator,\n                    new bytes(0)\n                )\n            ),\n            new bytes(0),\n            ctx\n        );\n    }\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.0;\n\nimport {\n    ISuperfluid,\n    ISuperToken\n} from \"../interfaces/superfluid/ISuperfluid.sol\";\n\nimport {\n    IConstantFlowAgreementV1\n} from \"../interfaces/agreements/IConstantFlowAgreementV1.sol\";\n\nimport {\n    IInstantDistributionAgreementV1\n} from \"../interfaces/agreements/IInstantDistributionAgreementV1.sol\";\n\n/**\n * @title Library for Token Centric Interface\n * @author Superfluid\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\n * of ISuperToken\n */\nlibrary SuperTokenV1Library {\n\n    /** CFA BASE CRUD ************************************* */\n\n    /**\n     * @dev Create flow without userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0) // userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Create flow with userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The userdata passed along with call\n     */\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            userData // userData\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev Update flow without userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0) // userData\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev Update flow with userData\n     * @param token The token used in flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The userdata passed along with call\n     */\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlow,\n                (token, receiver, flowRate, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Delete flow without userData\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     */\n    function deleteFlow(ISuperToken token, address sender, address receiver)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlow,\n                (token, sender, receiver, new bytes(0))\n            ),\n            new bytes(0) // userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Delete flow with userData\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param userData The userdata passed along with call\n     */\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\n        internal returns (bool)\n    {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlow,\n                (token, sender, receiver, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /** CFA ACL ************************************* */\n\n    /**\n     * @dev Update permissions for flow operator\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param allowCreate creation permissions\n     * @param allowCreate update permissions\n     * @param allowCreate deletion permissions\n     * @param flowRateAllowance The allowance provided to flowOperator\n     */\n    function setFlowPermissions(\n        ISuperToken token,\n        address flowOperator,\n        bool allowCreate,\n        bool allowUpdate,\n        bool allowDelete,\n        int96 flowRateAllowance\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\n            | (allowUpdate ? 1 : 0) << 1\n            | (allowDelete ? 1 : 0) << 2;\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowOperatorPermissions,\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Update permissions for flow operator - give operator max permissions\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     */\n    function setMaxFlowPermissions(\n        ISuperToken token,\n        address flowOperator\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.authorizeFlowOperatorWithFullControl,\n                (token, flowOperator, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Update permissions for flow operator - revoke all permission\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     */\n    function revokeFlowPermissions(\n        ISuperToken token,\n        address flowOperator\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.revokeFlowOperatorWithFullControl,\n                (token, flowOperator, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Update permissions for flow operator in callback\n     * @notice allowing userData to be a parameter here triggered stack to deep error\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param allowCreate creation permissions\n     * @param allowCreate update permissions\n     * @param allowCreate deletion permissions\n     * @param flowRateAllowance The allowance provided to flowOperator\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function setFlowPermissionsWithCtx(\n        ISuperToken token,\n        address flowOperator,\n        bool allowCreate,\n        bool allowUpdate,\n        bool allowDelete,\n        int96 flowRateAllowance,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\n            | (allowUpdate ? 1 : 0) << 1\n            | (allowDelete ? 1 : 0) << 2;\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowOperatorPermissions,\n                (\n                    token,\n                    flowOperator,\n                    permissionsBitmask,\n                    flowRateAllowance,\n                    new bytes(0)\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update permissions for flow operator - give operator max permissions\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function setMaxFlowPermissionsWithCtx(\n        ISuperToken token,\n        address flowOperator,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.authorizeFlowOperatorWithFullControl,\n                (\n                    token,\n                    flowOperator,\n                    new bytes(0)\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n    * @dev Update permissions for flow operator - revoke all permission\n     * @param token The token used in flow\n     * @param flowOperator The address given flow permissions\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function revokeFlowPermissionsWithCtx(\n        ISuperToken token,\n        address flowOperator,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.revokeFlowOperatorWithFullControl,\n                (token, flowOperator, new bytes(0))\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n\n    /**\n     * @dev Creates flow as an operator without userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function createFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Creates flow as an operator with userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function createFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n\n    /**\n     * @dev Updates flow as an operator without userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     */\n    function updateFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates flow as an operator with userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param userData The user provided data\n     */\n    function updateFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowByOperator,\n                (token, sender, receiver, flowRate, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n     /**\n     * @dev Deletes flow as an operator without userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     */\n    function deleteFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlowByOperator,\n                (token, sender, receiver, new bytes(0))\n            ),\n            new bytes(0)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Deletes flow as an operator with userData\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param userData The user provided data\n     */\n    function deleteFlowFrom(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        host.callAgreement(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlowByOperator,\n                (token, sender, receiver, new bytes(0))\n            ),\n            userData\n        );\n        return true;\n    }\n\n\n    /** CFA With CTX FUNCTIONS ************************************* */\n\n    /**\n     * @dev Create flow with context and userData\n     * @param token The token to flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function createFlowWithCtx(\n        ISuperToken token,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Create flow by operator with context\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function createFlowFromWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.createFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update flow with context\n     * @param token The token to flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function updateFlowWithCtx(\n        ISuperToken token,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlow,\n                (\n                    token,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Update flow by operator with context\n     * @param token The token to flow\n     * @param sender The receiver of the flow\n     * @param receiver The receiver of the flow\n     * @param flowRate The desired flowRate\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function updateFlowFromWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.updateFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    flowRate,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Delete flow with context\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function deleteFlowWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlow,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Delete flow by operator with context\n     * @param token The token to flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function deleteFlowFromWithCtx(\n        ISuperToken token,\n        address sender,\n        address receiver,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            cfa,\n            abi.encodeCall(\n                cfa.deleteFlowByOperator,\n                (\n                    token,\n                    sender,\n                    receiver,\n                    new bytes(0) // placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /** CFA VIEW FUNCTIONS ************************************* */\n\n    /**\n     * @dev get flow rate between two accounts for given token\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @return flowRate The flow rate\n     */\n    function getFlowRate(ISuperToken token, address sender, address receiver)\n        internal view returns(int96 flowRate)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\n    }\n\n    /**\n     * @dev get flow info between two accounts for given token\n     * @param token The token used in flow\n     * @param sender The sender of the flow\n     * @param receiver The receiver of the flow\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\n     * @return flowRate The flow rate\n     * @return deposit The amount of deposit the flow\n     * @return owedDeposit The amount of owed deposit of the flow\n     */\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\n        internal view\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\n    }\n\n    /**\n     * @dev get net flow rate for given account for given token\n     * @param token Super token address\n     * @param account Account to query\n     * @return flowRate The net flow rate of the account\n     */\n    function getNetFlowRate(ISuperToken token, address account)\n        internal view returns (int96 flowRate)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        return cfa.getNetFlow(token, account);\n    }\n\n    /**\n     * @dev get the aggregated flow info of the account\n     * @param token Super token address\n     * @param account Account to query\n     * @return lastUpdated Timestamp of the last change of the net flow\n     * @return flowRate The net flow rate of token for account\n     * @return deposit The sum of all deposits for account's flows\n     * @return owedDeposit The sum of all owed deposits for account's flows\n     */\n    function getNetFlowInfo(ISuperToken token, address account)\n        internal view\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        return cfa.getAccountFlowInfo(token, account);\n    }\n\n    /**\n     * @dev calculate buffer for a flow rate\n     * @param token The token used in flow\n     * @param flowRate The flowrate to calculate the needed buffer for\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\n     */\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\n        returns (uint256 bufferAmount)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\n    }\n\n    /**\n     * @dev get existing flow permissions\n     * @param token The token used in flow\n     * @param sender sender of a flow\n     * @param flowOperator the address we are checking permissions of for sender & token\n     * @return allowCreate is true if the flowOperator can create flows\n     * @return allowUpdate is true if the flowOperator can update flows\n     * @return allowDelete is true if the flowOperator can delete flows\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\n     */\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\n        internal view\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\n    {\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\n        uint8 permissionsBitmask;\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\n        allowCreate = permissionsBitmask & 1 == 1 ? true : false;\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1 ? true : false;\n        allowDelete = permissionsBitmask >> 2 & 1 == 1 ? true : false;\n    }\n\n\n     /** IDA VIEW FUNCTIONS ************************************* */\n\n\n    /**\n     * @dev Gets an index by its ID and publisher.\n     * @param token Super token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @return exist True if the index exists.\n     * @return indexValue Total value of the index.\n     * @return totalUnitsApproved Units of the index approved by subscribers.\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\n     */\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\n        internal view\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.getIndex(token, publisher, indexId);\n    }\n\n    /**\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\n     * @param token Super token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param amount Amount of tokens desired to distribute.\n     * @return actualAmount Amount to be distributed with correct rounding.\n     * @return newIndexValue The index value after the distribution would be called.\n     */\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\n        internal view\n        returns (uint256 actualAmount, uint128 newIndexValue)\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.calculateDistribution(token, publisher, indexId, amount);\n    }\n\n    /**\n     * @dev List all subscriptions of an address\n     * @param token Super token used in the indexes listed.\n     * @param subscriber Subscriber address.\n     * @return publishers Publishers of the indices.\n     * @return indexIds IDs of the indices.\n     * @return unitsList Units owned of the indices.\n     */\n    function listSubscriptions(\n        ISuperToken token,\n        address subscriber\n    )\n        internal view\n        returns (\n            address[] memory publishers,\n            uint32[] memory indexIds,\n            uint128[] memory unitsList\n        )\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.listSubscriptions(token, subscriber);\n    }\n\n    /**\n     * @dev Gets subscription by publisher, index id, and subscriber.\n     * @param token Super token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber to the index.\n     * @return exist True if the subscription exists.\n     * @return approved True if the subscription has been approved by the subscriber.\n     * @return units Units held by the subscriber\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\n     */\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\n        internal view\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.getSubscription(token, publisher, indexId, subscriber);\n    }\n\n    /*\n     * @dev Gets subscription by the agreement ID.\n     * @param token Super Token used with the index.\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\n     * @return publisher Publisher of the index.\n     * @return indexId ID of the index.\n     * @return approved True if the subscription has been approved by the subscriber.\n     * @return units Units held by the subscriber\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\n     */\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\n        internal view\n        returns (\n            address publisher,\n            uint32 indexId,\n            bool approved,\n            uint128 units,\n            uint256 pendingDistribution\n        )\n    {\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\n        return ida.getSubscriptionByID(token, agreementId);\n    }\n\n\n    /** IDA BASE FUNCTIONS ************************************* */\n\n\n    /**\n     * @dev Creates a new index.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     */\n    function createIndex(\n        ISuperToken token,\n        uint32 indexId\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.createIndex,\n                (\n                    token,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Creates a new index with userData.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param userData Arbitrary user data field.\n     */\n    function createIndex(\n        ISuperToken token,\n        uint32 indexId,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.createIndex,\n                (\n                    token,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates an index value. This distributes an amount of tokens equal to\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\n     */\n    function updateIndexValue(\n        ISuperToken token,\n        uint32 indexId,\n        uint128 indexValue\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.updateIndex,\n                (\n                    token,\n                    indexId,\n                    indexValue,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\n     * @param userData Arbitrary user data field.\n     */\n    function updateIndexValue(\n        ISuperToken token,\n        uint32 indexId,\n        uint128 indexValue,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.updateIndex,\n                (\n                    token,\n                    indexId,\n                    indexValue,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\n     * passing the new total index value, this function will increase the index value by `amount`.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param amount Amount by which the index value should increase.\n     */\n    function distribute(\n        ISuperToken token,\n        uint32 indexId,\n        uint256 amount\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.distribute,\n                (\n                    token,\n                    indexId,\n                    amount,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\n     * passing the new total index value, this function will increase the index value by `amount`.\n     * This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param amount Amount by which the index value should increase.\n     * @param userData Arbitrary user data field.\n     */\n    function distribute(\n        ISuperToken token,\n        uint32 indexId,\n        uint256 amount,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.distribute,\n                (\n                    token,\n                    indexId,\n                    amount,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\n     * until the subscription is approved, but once approved, the balance will be updated with\n     * prior distributions.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     */\n    function approveSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.approveSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\n     * until the subscription is approved, but once approved, the balance will be updated with\n     * prior distributions.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param userData Arbitrary user data field.\n     */\n    function approveSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.approveSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Revokes a previously approved subscription.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     */\n    function revokeSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.revokeSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param userData Arbitrary user data field.\n     */\n    function revokeSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.revokeSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be updated.\n     * @param units New number of units the subscriber holds.\n     */\n    function updateSubscriptionUnits(\n        ISuperToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n         ida,\n            abi.encodeCall(\n                ida.updateSubscription,\n                (\n                    token,\n                    indexId,\n                    subscriber,\n                    units,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\n     * holds. This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be updated.\n     * @param units New number of units the subscriber holds.\n     * @param userData Arbitrary user data field.\n     */\n    function updateSubscriptionUnits(\n        ISuperToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n         ida,\n            abi.encodeCall(\n                ida.updateSubscription,\n                (\n                    token,\n                    indexId,\n                    subscriber,\n                    units,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Deletes a subscription, setting a subcriber's units to zero\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be deleted.\n     */\n    function deleteSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.deleteSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be deleted.\n     * @param userData Arbitrary user data field.\n     */\n    function deleteSubscription(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory userData\n    ) internal returns (bool) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.deleteSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /**\n     * @dev Claims pending distribution. Subscription should not be approved\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address that receives the claim.\n     */\n    function claim(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber\n    ) internal returns (bool) {\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.claim,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\"\n        );\n        return true;\n    }\n\n    /**\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address that receives the claim.\n     * @param userData Arbitrary user data field.\n     */\n    function claim(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory userData\n    ) internal returns (bool) {\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        host.callAgreement(\n            ida,\n            abi.encodeCall(\n                ida.claim,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            userData\n        );\n        return true;\n    }\n\n    /** IDA WITH CTX FUNCTIONS ************************************* */\n\n    /**\n     * @dev Creates a new index with ctx.\n     * Meant for usage in super app callbacks\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param ctx from super app callback\n     */\n    function createIndexWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.createIndex,\n                (\n                    token,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\n     * Meant for usage in super app callbakcs\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\n     * @param ctx from super app callback\n     */\n    function updateIndexValueWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        uint128 indexValue,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.updateIndex,\n                (\n                    token,\n                    indexId,\n                    indexValue,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\n     * passing the new total index value, this function will increase the index value by `amount`.\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param amount Amount by which the index value should increase.\n     * @param ctx from super app callback\n     */\n    function distributeWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        uint256 amount,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.distribute,\n                (\n                    token,\n                    indexId,\n                    amount,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\n     * until the subscription is approved, but once approved, the balance will be updated with\n     * prior distributions.\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param ctx from super app callback\n     */\n    function approveSubscriptionWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.approveSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param ctx from super app callback\n     */\n    function revokeSubscriptionWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.revokeSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\n     * holds. Meant for usage in super apps\n     * @param token Super Token used with the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be updated.\n     * @param units New number of units the subscriber holds.\n     * @param ctx from super app callback\n     */\n    function updateSubscriptionUnitsWithCtx(\n        ISuperToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n         ida,\n            abi.encodeCall(\n                ida.updateSubscription,\n                (\n                    token,\n                    indexId,\n                    subscriber,\n                    units,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\n     * Meant for usage in super apps\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address whose units are to be deleted.\n     * @param ctx from super app callback\n     */\n    function deleteSubscriptionWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.deleteSubscription,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    /**\n     * @dev Claims pending distribution. Subscription should not be approved.\n     * Meant for usage in super app callbacks\n     * @param token Super Token used with the index.\n     * @param publisher Publisher of the index.\n     * @param indexId ID of the index.\n     * @param subscriber Subscriber address that receives the claim.\n     * @param ctx from super app callback\n     */\n    function claimWithCtx(\n        ISuperToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes memory ctx\n    ) internal returns (bytes memory newCtx) {\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\n        (newCtx, ) = host.callAgreementWithContext(\n            ida,\n            abi.encodeCall(\n                ida.claim,\n                (\n                    token,\n                    publisher,\n                    indexId,\n                    subscriber,\n                    new bytes(0) // ctx placeholder\n                )\n            ),\n            \"0x\",\n            ctx\n        );\n    }\n\n    // ************** private helpers **************\n\n    // keccak256(\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\")\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\n    // keccak256(\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\")\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\n    // keccak256(\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\");\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\n\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\n    // to be used in state changing methods\n    function _getAndCacheHostAndCFA(ISuperToken token) private\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            cfa := sload(_CFA_SLOT)\n        }\n        if (address(cfa) == address(0)) {\n            // framework contract addrs not yet cached, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                //keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\")\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\n            // now that we got them and are in a transaction context, persist in storage\n            assembly {\n            // solium-disable-line\n                sstore(_HOST_SLOT, host)\n                sstore(_CFA_SLOT, cfa)\n            }\n        }\n        assert(address(host) != address(0));\n        assert(address(cfa) != address(0));\n    }\n\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\n    // to be used in state changing methods\n    function _getAndCacheHostAndIDA(ISuperToken token) private\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            ida := sload(_IDA_SLOT)\n        }\n        if (address(ida) == address(0)) {\n            // framework contract addrs not yet cached, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                    keccak256(\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\"))));\n            // now that we got them and are in a transaction context, persist in storage\n            assembly {\n            // solium-disable-line\n                sstore(_HOST_SLOT, host)\n                sstore(_IDA_SLOT, ida)\n            }\n        }\n        assert(address(host) != address(0));\n        assert(address(ida) != address(0));\n    }\n\n    // gets the host and cfa addrs for the token\n    // to be used in non-state changing methods (view functions)\n    function _getHostAndCFA(ISuperToken token) private view\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            cfa := sload(_CFA_SLOT)\n        }\n        if (address(cfa) == address(0)) {\n            // framework contract addrs not yet cached in storage, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                //keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\")\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\n        }\n        assert(address(host) != address(0));\n        assert(address(cfa) != address(0));\n    }\n\n    // gets the host and ida addrs for the token\n    // to be used in non-state changing methods (view functions)\n    function _getHostAndIDA(ISuperToken token) private view\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\n    {\n        // check if already in contract storage...\n        assembly { // solium-disable-line\n            host := sload(_HOST_SLOT)\n            ida := sload(_IDA_SLOT)\n        }\n        if (address(ida) == address(0)) {\n            // framework contract addrs not yet cached in storage, retrieving now...\n            if (address(host) == address(0)) {\n                host = ISuperfluid(token.getHost());\n            }\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\n                //keccak256(\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\")\n                    0x15609310ae3c30189a1218b7adabaf36c267255e70cf91b6cba384367d9eda32)));\n        }\n        assert(address(host) != address(0));\n        assert(address(ida) != address(0));\n    }\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"../superfluid/ISuperAgreement.sol\";\nimport { ISuperfluidToken } from \"../superfluid/ISuperfluidToken.sol\";\n\n/**\n * @title Constant Flow Agreement interface\n * @author Superfluid\n */\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\n\n    /// @dev ISuperAgreement.agreementType implementation\n    function agreementType() external override pure returns (bytes32) {\n        return keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\");\n    }\n\n    /**\n     * @notice Get the maximum flow rate allowed with the deposit\n     * @dev The deposit is clipped and rounded down\n     * @param deposit Deposit amount used for creating the flow\n     * @return flowRate The maximum flow rate\n     */\n    function getMaximumFlowRateFromDeposit(\n        ISuperfluidToken token,\n        uint256 deposit)\n        external view virtual\n        returns (int96 flowRate);\n\n    /**\n     * @notice Get the deposit required for creating the flow\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\n     * @param flowRate Flow rate to be tested\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\n     * @custom:note \n     * - if calculated deposit (flowRate * liquidationPeriod) is less\n     *   than the minimum deposit, we use the minimum deposit otherwise\n     *   we use the calculated deposit\n     */\n    function getDepositRequiredForFlowRate(\n        ISuperfluidToken token,\n        int96 flowRate)\n        external view virtual\n        returns (uint256 deposit);\n\n    /**\n     * @dev Returns whether it is the patrician period based on host.getNow()\n     * @param account The account we are interested in\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\n     * @return timestamp The value of host.getNow()\n     */\n    function isPatricianPeriodNow(\n        ISuperfluidToken token,\n        address account)\n        external view virtual\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\n\n    /**\n     * @dev Returns whether it is the patrician period based on timestamp\n     * @param account The account we are interested in\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\n     * @return bool Whether it is currently the patrician period dictated by governance\n     */\n    function isPatricianPeriod(\n        ISuperfluidToken token,\n        address account,\n        uint256 timestamp\n    )\n        public view virtual\n        returns (bool);\n\n    /**\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param permissions A bitmask representation of the granted permissions\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function updateFlowOperatorPermissions(\n        ISuperfluidToken token,\n        address flowOperator,\n        uint8 permissions,\n        int96 flowRateAllowance,\n        bytes calldata ctx\n    ) \n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function authorizeFlowOperatorWithFullControl(\n        ISuperfluidToken token,\n        address flowOperator,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n     /**\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\n     * @param token Super token address\n     * @param flowOperator The permission grantee address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     */\n    function revokeFlowOperatorWithFullControl(\n        ISuperfluidToken token,\n        address flowOperator,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\n     * @param token Super token address\n     * @param sender The permission granter address\n     * @param flowOperator The permission grantee address\n     * @return flowOperatorId The keccak256 hash of encoded string \"flowOperator\", sender and flowOperator\n     * @return permissions A bitmask representation of the granted permissions\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     */\n    function getFlowOperatorData(\n       ISuperfluidToken token,\n       address sender,\n       address flowOperator\n    )\n        public view virtual\n        returns (\n            bytes32 flowOperatorId,\n            uint8 permissions,\n            int96 flowRateAllowance\n        );\n\n    /**\n     * @notice Get flow operator using flowOperatorId\n     * @param token Super token address\n     * @param flowOperatorId The keccak256 hash of encoded string \"flowOperator\", sender and flowOperator\n     * @return permissions A bitmask representation of the granted permissions\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     */\n    function getFlowOperatorDataByID(\n       ISuperfluidToken token,\n       bytes32 flowOperatorId\n    )\n        external view virtual\n        returns (\n            uint8 permissions,\n            int96 flowRateAllowance\n        );\n\n    /**\n     * @notice Create a flow betwen ctx.msgSender and receiver\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param receiver Flow receiver address\n     * @param flowRate New flow rate in amount per second\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - AgreementCreated\n     *   - agreementId - can be used in getFlowByID\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\n     *\n     * @custom:note \n     * - A deposit is taken as safety margin for the solvency agents\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\n     */\n    function createFlow(\n        ISuperfluidToken token,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n    * @notice Create a flow between sender and receiver\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\n    * @param token Super token address\n    * @param sender Flow sender address (has granted permissions)\n    * @param receiver Flow receiver address\n    * @param flowRate New flow rate in amount per second\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    */\n    function createFlowByOperator(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice Update the flow rate between ctx.msgSender and receiver\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param receiver Flow receiver address\n     * @param flowRate New flow rate in amount per second\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - AgreementUpdated\n     *   - agreementId - can be used in getFlowByID\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\n     *\n     * @custom:note \n     * - Only the flow sender may update the flow rate\n     * - Even if the flow rate is zero, the flow is not deleted\n     * from the system\n     * - Deposit amount will be adjusted accordingly\n     * - No new gas fee is charged\n     */\n    function updateFlow(\n        ISuperfluidToken token,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n    * @notice Update a flow between sender and receiver\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\n    * @param token Super token address\n    * @param sender Flow sender address (has granted permissions)\n    * @param receiver Flow receiver address\n    * @param flowRate New flow rate in amount per second\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    */\n    function updateFlowByOperator(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        int96 flowRate,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @dev Get the flow data between `sender` and `receiver` of `token`\n     * @param token Super token address\n     * @param sender Flow receiver\n     * @param receiver Flow sender\n     * @return timestamp Timestamp of when the flow is updated\n     * @return flowRate The flow rate\n     * @return deposit The amount of deposit the flow\n     * @return owedDeposit The amount of owed deposit of the flow\n     */\n    function getFlow(\n        ISuperfluidToken token,\n        address sender,\n        address receiver\n    )\n        external view virtual\n        returns (\n            uint256 timestamp,\n            int96 flowRate,\n            uint256 deposit,\n            uint256 owedDeposit\n        );\n\n    /**\n     * @notice Get flow data using agreementId\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param agreementId The agreement ID\n     * @return timestamp Timestamp of when the flow is updated\n     * @return flowRate The flow rate\n     * @return deposit The deposit amount of the flow\n     * @return owedDeposit The owed deposit amount of the flow\n     */\n    function getFlowByID(\n       ISuperfluidToken token,\n       bytes32 agreementId\n    )\n        external view virtual\n        returns (\n            uint256 timestamp,\n            int96 flowRate,\n            uint256 deposit,\n            uint256 owedDeposit\n        );\n\n    /**\n     * @dev Get the aggregated flow info of the account\n     * @param token Super token address\n     * @param account Account for the query\n     * @return timestamp Timestamp of when a flow was last updated for account\n     * @return flowRate The net flow rate of token for account\n     * @return deposit The sum of all deposits for account's flows\n     * @return owedDeposit The sum of all owed deposits for account's flows\n     */\n    function getAccountFlowInfo(\n        ISuperfluidToken token,\n        address account\n    )\n        external view virtual\n        returns (\n            uint256 timestamp,\n            int96 flowRate,\n            uint256 deposit,\n            uint256 owedDeposit);\n\n    /**\n     * @dev Get the net flow rate of the account\n     * @param token Super token address\n     * @param account Account for the query\n     * @return flowRate Net flow rate\n     */\n    function getNetFlow(\n        ISuperfluidToken token,\n        address account\n    )\n        external view virtual\n        returns (int96 flowRate);\n\n    /**\n     * @notice Delete the flow between sender and receiver\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\n     * @param token Super token address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver Flow receiver address\n     *\n     * @custom:callbacks \n     * - AgreementTerminated\n     *   - agreementId - can be used in getFlowByID\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\n     *\n     * @custom:note \n     * - Both flow sender and receiver may delete the flow\n     * - If Sender account is insolvent or in critical state, a solvency agent may\n     *   also terminate the agreement\n     * - Gas fee may be returned to the sender\n     */\n    function deleteFlow(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n\n    /**\n     * @notice Delete the flow between sender and receiver\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\n     * @param token Super token address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     * @param receiver Flow receiver address\n     */\n    function deleteFlowByOperator(\n        ISuperfluidToken token,\n        address sender,\n        address receiver,\n        bytes calldata ctx\n    )\n        external virtual\n        returns(bytes memory newCtx);\n     \n    /**\n     * @dev Flow operator updated event\n     * @param token Super token address\n     * @param sender Flow sender address\n     * @param flowOperator Flow operator address\n     * @param permissions Octo bitmask representation of permissions\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\n     */\n    event FlowOperatorUpdated(\n        ISuperfluidToken indexed token,\n        address indexed sender,\n        address indexed flowOperator,\n        uint8 permissions,\n        int96 flowRateAllowance\n    );\n\n    /**\n     * @dev Flow updated event\n     * @param token Super token address\n     * @param sender Flow sender address\n     * @param receiver Flow recipient address\n     * @param flowRate Flow rate in amount per second for this flow\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\n     * @param userData The user provided data\n     *\n     */\n    event FlowUpdated(\n        ISuperfluidToken indexed token,\n        address indexed sender,\n        address indexed receiver,\n        int96 flowRate,\n        int256 totalSenderFlowRate,\n        int256 totalReceiverFlowRate,\n        bytes userData\n    );\n\n    /**\n     * @dev Flow updated extension event\n     * @param flowOperator Flow operator address - the Context.msgSender\n     * @param deposit The deposit amount for the stream\n     */\n    event FlowUpdatedExtension(\n        address indexed flowOperator,\n        uint256 deposit\n    );\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"../superfluid/ISuperAgreement.sol\";\nimport { ISuperfluidToken } from \"../superfluid/ISuperfluidToken.sol\";\n\n\n/**\n * @title Instant Distribution Agreement interface\n * @author Superfluid\n *\n * @notice \n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\n *       Despite knowing sha-3 collision is only theoretical.\n *   - A publisher can create a subscription to an index for any subscriber.\n *   - A subscription consists of:\n *     - The index it subscribes to.\n *     - Number of units subscribed.\n *   - An index consists of:\n *     - Current value as `uint128 indexValue`.\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\n *   - A publisher can update an index with a new value that doesn't decrease.\n *   - A publisher can update a subscription with any number of units.\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\n *   - A subscriber must approve the index in order to receive distributions from the publisher\n *     each time the index is updated.\n *     - The amount distributed is $$\\Delta{index} * units$$\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\n *     - the subscriber approves the subscription (side effect),\n *     - the publisher updates the subscription (side effect),\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\n *     - or the subscriber can explicitly claim them.\n */\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\n\n    /// @dev ISuperAgreement.agreementType implementation\n    function agreementType() external override pure returns (bytes32) {\n        return keccak256(\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\");\n    }\n\n    /**************************************************************************\n     * Index operations\n     *************************************************************************/\n\n    /**\n     * @dev Create a new index for the publisher\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * None\n     */\n    function createIndex(\n        ISuperfluidToken token,\n        uint32 indexId,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n    /**\n    * @dev Index created event\n    * @param token Super token address\n    * @param publisher Index creator and publisher\n    * @param indexId The specified indexId of the newly created index\n    * @param userData The user provided data\n    */\n    event IndexCreated(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        bytes userData);\n\n    /**\n     * @dev Query the data of a index\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @return exist Does the index exist\n     * @return indexValue Value of the current index\n     * @return totalUnitsApproved Total units approved for the index\n     * @return totalUnitsPending Total units pending approval for the index\n     */\n    function getIndex(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId)\n            external\n            view\n            virtual\n            returns(\n                bool exist,\n                uint128 indexValue,\n                uint128 totalUnitsApproved,\n                uint128 totalUnitsPending);\n\n    /**\n     * @dev Calculate actual distribution amount\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param amount The amount of tokens desired to be distributed\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\n     */\n    function calculateDistribution(\n       ISuperfluidToken token,\n       address publisher,\n       uint32 indexId,\n       uint256 amount)\n           external view\n           virtual\n           returns(\n               uint256 actualAmount,\n               uint128 newIndexValue);\n\n    /**\n     * @dev Update index value of an index\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param indexValue Value of the index\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * None\n     */\n    function updateIndex(\n        ISuperfluidToken token,\n        uint32 indexId,\n        uint128 indexValue,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n    /**\n      * @dev Index updated event\n      * @param token Super token address\n      * @param publisher Index updater and publisher\n      * @param indexId The specified indexId of the updated index\n      * @param oldIndexValue The previous index value\n      * @param newIndexValue The updated index value\n      * @param totalUnitsPending The total units pending when the indexValue was updated\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\n      * @param userData The user provided data\n      */\n    event IndexUpdated(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        uint128 oldIndexValue,\n        uint128 newIndexValue,\n        uint128 totalUnitsPending,\n        uint128 totalUnitsApproved,\n        bytes userData);\n\n    /**\n     * @dev Distribute tokens through the index\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param amount The amount of tokens desired to be distributed\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:note \n     * - This is a convenient version of updateIndex. It adds to the index\n     *   a delta that equals to `amount / totalUnits`\n     * - The actual amount distributed could be obtained via\n     *   `calculateDistribution`. This is due to precision error with index\n     *   value and units data range\n     *\n     * @custom:callbacks \n     * None\n     */\n    function distribute(\n        ISuperfluidToken token,\n        uint32 indexId,\n        uint256 amount,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n\n\n    /**************************************************************************\n     * Subscription operations\n     *************************************************************************/\n\n    /**\n     * @dev Approve the subscription of an index\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - if subscription exist\n     *   - AgreementCreated callback to the publisher:\n     *      - agreementId is for the subscription\n     * - if subscription does not exist\n     *   - AgreementUpdated callback to the publisher:\n     *      - agreementId is for the subscription\n     */\n    function approveSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n    /**\n      * @dev Index subscribed event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The approved subscriber\n      * @param userData The user provided data\n      */\n    event IndexSubscribed(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        bytes userData);\n\n    /**\n      * @dev Subscription approved event\n      * @param token Super token address\n      * @param subscriber The approved subscriber\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param userData The user provided data\n      */\n    event SubscriptionApproved(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        bytes userData);\n\n    /**\n    * @notice Revoke the subscription of an index\n    * @dev \"Unapproves\" the subscription and moves approved units to pending\n    * @param token Super token address\n    * @param publisher The publisher of the index\n    * @param indexId Id of the index\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    *\n    * @custom:callbacks \n    * - AgreementUpdated callback to the publisher:\n    *    - agreementId is for the subscription\n    */\n    function revokeSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        bytes calldata ctx)\n         external\n         virtual\n         returns(bytes memory newCtx);\n    /**\n      * @dev Index unsubscribed event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The unsubscribed subscriber\n      * @param userData The user provided data\n      */\n    event IndexUnsubscribed(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        bytes userData);\n    \n    /**\n      * @dev Subscription approved event\n      * @param token Super token address\n      * @param subscriber The approved subscriber\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param userData The user provided data\n      */\n    event SubscriptionRevoked(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        bytes userData);\n\n    /**\n     * @dev Update the nuber of units of a subscription\n     * @param token Super token address\n     * @param indexId Id of the index\n     * @param subscriber The subscriber of the index\n     * @param units Number of units of the subscription\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - if subscription exist\n     *   - AgreementCreated callback to the subscriber:\n     *      - agreementId is for the subscription\n     * - if subscription does not exist\n     *   - AgreementUpdated callback to the subscriber:\n     *      - agreementId is for the subscription\n     */\n    function updateSubscription(\n        ISuperfluidToken token,\n        uint32 indexId,\n        address subscriber,\n        uint128 units,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n\n    /**\n      * @dev Index units updated event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The subscriber units updated\n      * @param units The new units amount\n      * @param userData The user provided data\n      */\n    event IndexUnitsUpdated(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        uint128 units,\n        bytes userData);\n    \n    /**\n      * @dev Subscription units updated event\n      * @param token Super token address\n      * @param subscriber The subscriber units updated\n      * @param indexId The specified indexId\n      * @param publisher Index publisher\n      * @param units The new units amount\n      * @param userData The user provided data\n      */\n    event SubscriptionUnitsUpdated(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        uint128 units,\n        bytes userData);\n\n    /**\n     * @dev Get data of a subscription\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param subscriber The subscriber of the index\n     * @return exist Does the subscription exist?\n     * @return approved Is the subscription approved?\n     * @return units Units of the suscription\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\n     */\n    function getSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber)\n            external\n            view\n            virtual\n            returns(\n                bool exist,\n                bool approved,\n                uint128 units,\n                uint256 pendingDistribution\n            );\n\n    /**\n     * @notice Get data of a subscription by agreement ID\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\"publisher\", publisher, indexId)\n     * @param token Super token address\n     * @param agreementId The agreement ID\n     * @return publisher The publisher of the index\n     * @return indexId Id of the index\n     * @return approved Is the subscription approved?\n     * @return units Units of the suscription\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\n     */\n    function getSubscriptionByID(\n        ISuperfluidToken token,\n        bytes32 agreementId)\n            external\n            view\n            virtual\n            returns(\n                address publisher,\n                uint32 indexId,\n                bool approved,\n                uint128 units,\n                uint256 pendingDistribution\n            );\n\n    /**\n     * @dev List subscriptions of an user\n     * @param token Super token address\n     * @param subscriber The subscriber's address\n     * @return publishers Publishers of the subcriptions\n     * @return indexIds Indexes of the subscriptions\n     * @return unitsList Units of the subscriptions\n     */\n    function listSubscriptions(\n        ISuperfluidToken token,\n        address subscriber)\n            external\n            view\n            virtual\n            returns(\n                address[] memory publishers,\n                uint32[] memory indexIds,\n                uint128[] memory unitsList);\n\n    /**\n     * @dev Delete the subscription of an user\n     * @param token Super token address\n     * @param publisher The publisher of the index\n     * @param indexId Id of the index\n     * @param subscriber The subscriber's address\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n     *\n     * @custom:callbacks \n     * - if the subscriber called it\n     *   - AgreementTerminated callback to the publsiher:\n     *      - agreementId is for the subscription\n     * - if the publisher called it\n     *   - AgreementTerminated callback to the subscriber:\n     *      - agreementId is for the subscription\n     */\n    function deleteSubscription(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes calldata ctx)\n            external\n            virtual\n            returns(bytes memory newCtx);\n\n    /**\n    * @dev Claim pending distributions\n    * @param token Super token address\n    * @param publisher The publisher of the index\n    * @param indexId Id of the index\n    * @param subscriber The subscriber's address\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\n    *\n    * @custom:note The subscription should not be approved yet\n    *\n    * @custom:callbacks \n    * - AgreementUpdated callback to the publisher:\n    *    - agreementId is for the subscription\n    */\n    function claim(\n        ISuperfluidToken token,\n        address publisher,\n        uint32 indexId,\n        address subscriber,\n        bytes calldata ctx)\n        external\n        virtual\n        returns(bytes memory newCtx);\n    \n    /**\n      * @dev Index distribution claimed event\n      * @param token Super token address\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param subscriber The subscriber units updated\n      * @param amount The pending amount claimed\n      */\n    event IndexDistributionClaimed(\n        ISuperfluidToken indexed token,\n        address indexed publisher,\n        uint32 indexed indexId,\n        address subscriber,\n        uint256 amount);\n    \n    /**\n      * @dev Subscription distribution claimed event\n      * @param token Super token address\n      * @param subscriber The subscriber units updated\n      * @param publisher Index publisher\n      * @param indexId The specified indexId\n      * @param amount The pending amount claimed\n      */\n    event SubscriptionDistributionClaimed(\n        ISuperfluidToken indexed token,\n        address indexed subscriber,\n        address publisher,\n        uint32 indexId,\n        uint256 amount);\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\n/**\n * @title Super app definitions library\n * @author Superfluid\n */\nlibrary SuperAppDefinitions {\n\n    /**************************************************************************\n    / App manifest config word\n    /**************************************************************************/\n\n    /*\n     * App level is a way to allow the app to whitelist what other app it can\n     * interact with (aka. composite app feature).\n     *\n     * For more details, refer to the technical paper of superfluid protocol.\n     */\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\n\n    // The app is at the final level, hence it doesn't want to interact with any other app\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\n\n    // The app is at the second level, it may interact with other final level apps if whitelisted\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\n\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\n        return uint8(configWord & APP_LEVEL_MASK);\n    }\n\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\n    }\n\n    /**************************************************************************\n    / Callback implementation bit masks\n    /**************************************************************************/\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\n\n    /**************************************************************************\n    / App Jail Reasons\n    /**************************************************************************/\n\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\n\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\n    }\n}\n\n/**\n * @title Context definitions library\n * @author Superfluid\n */\nlibrary ContextDefinitions {\n\n    /**************************************************************************\n    / Call info\n    /**************************************************************************/\n\n    // app level\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\n\n    // call type\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\n\n    function decodeCallInfo(uint256 callInfo)\n        internal pure\n        returns (uint8 appCallbackLevel, uint8 callType)\n    {\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\n    }\n\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\n        internal pure\n        returns (uint256 callInfo)\n    {\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\n    }\n\n}\n\n/**\n * @title Flow Operator definitions library\n  * @author Superfluid\n */\n library FlowOperatorDefinitions {\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\n\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\n        return (\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\n            ) == uint8(0);\n    }\n }\n\n/**\n * @title Batch operation library\n * @author Superfluid\n */\nlibrary BatchOperation {\n    /**\n     * @dev ERC20.approve batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationApprove(\n     *     abi.decode(data, (address spender, uint256 amount))\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\n    /**\n     * @dev ERC20.transferFrom batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationTransferFrom(\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\n    /**\n     * @dev ERC777.send batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationSend(\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\n    /**\n     * @dev SuperToken.upgrade batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationUpgrade(\n     *     abi.decode(data, (uint256 amount)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\n    /**\n     * @dev SuperToken.downgrade batch operation type\n     *\n     * Call spec:\n     * ISuperToken(target).operationDowngrade(\n     *     abi.decode(data, (uint256 amount)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\n    /**\n     * @dev Superfluid.callAgreement batch operation type\n     *\n     * Call spec:\n     * callAgreement(\n     *     ISuperAgreement(target)),\n     *     abi.decode(data, (bytes callData, bytes userData)\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\n    /**\n     * @dev Superfluid.callAppAction batch operation type\n     *\n     * Call spec:\n     * callAppAction(\n     *     ISuperApp(target)),\n     *     data\n     * )\n     */\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\n}\n\n/**\n * @title Superfluid governance configs library\n * @author Superfluid\n */\nlibrary SuperfluidGovernanceConfigs {\n\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\n        keccak256(\"org.superfluid-finance.superfluid.rewardAddress\");\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\n        keccak256(\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\");\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\n        keccak256(\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\");\n\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            \"org.superfluid-finance.superfluid.trustedForwarder\",\n            forwarder));\n    }\n\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            \"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\",\n            deployer,\n            registrationKey));\n    }\n\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            \"org.superfluid-finance.superfluid.appWhiteListing.factory\",\n            factory));\n    }\n\n    function decodePPPConfig(uint256 pppConfig) internal pure returns (uint256 liquidationPeriod, uint256 patricianPeriod) {\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\n        patricianPeriod = pppConfig & type(uint32).max;\n    }\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\n\n/**\n * @title Super agreement interface\n * @author Superfluid\n */\ninterface ISuperAgreement {\n\n    /**\n     * @dev Get the type of the agreement class\n     */\n    function agreementType() external view returns (bytes32);\n\n    /**\n     * @dev Calculate the real-time balance for the account of this agreement class\n     * @param account Account the state belongs to\n     * @param time Time used for the calculation\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\n     * @return deposit Account deposit amount of this agreement\n     * @return owedDeposit Account owed deposit amount of this agreement\n     */\n    function realtimeBalanceOf(\n        ISuperfluidToken token,\n        address account,\n        uint256 time\n    )\n        external\n        view\n        returns (\n            int256 dynamicBalance,\n            uint256 deposit,\n            uint256 owedDeposit\n        );\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperToken } from \"./ISuperToken.sol\";\n\n/**\n * @title SuperApp interface\n * @author Superfluid\n * @dev Be aware of the app being jailed, when the word permitted is used.\n */\ninterface ISuperApp {\n\n    /**\n     * @dev Callback before a new agreement is created.\n     * @param superToken The super token used for the agreement.\n     * @param agreementClass The agreement class address.\n     * @param agreementId The agreementId\n     * @param agreementData The agreement data (non-compressed)\n     * @param ctx The context data.\n     * @return cbdata A free format in memory data the app can use to pass\n     *          arbitary information to the after-hook callback.\n     *\n     * @custom:note \n     * - It will be invoked with `staticcall`, no state changes are permitted.\n     * - Only revert with a \"reason\" is permitted.\n     */\n    function beforeAgreementCreated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata ctx\n    )\n        external\n        view\n        returns (bytes memory cbdata);\n\n    /**\n     * @dev Callback after a new agreement is created.\n     * @param superToken The super token used for the agreement.\n     * @param agreementClass The agreement class address.\n     * @param agreementId The agreementId\n     * @param agreementData The agreement data (non-compressed)\n     * @param cbdata The data returned from the before-hook callback.\n     * @param ctx The context data.\n     * @return newCtx The current context of the transaction.\n     *\n     * @custom:note \n     * - State changes is permitted.\n     * - Only revert with a \"reason\" is permitted.\n     */\n    function afterAgreementCreated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata cbdata,\n        bytes calldata ctx\n    )\n        external\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev Callback before a new agreement is updated.\n     * @param superToken The super token used for the agreement.\n     * @param agreementClass The agreement class address.\n     * @param agreementId The agreementId\n     * @param agreementData The agreement data (non-compressed)\n     * @param ctx The context data.\n     * @return cbdata A free format in memory data the app can use to pass\n     *          arbitary information to the after-hook callback.\n     *\n     * @custom:note \n     * - It will be invoked with `staticcall`, no state changes are permitted.\n     * - Only revert with a \"reason\" is permitted.\n     */\n    function beforeAgreementUpdated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata ctx\n    )\n        external\n        view\n        returns (bytes memory cbdata);\n\n\n    /**\n    * @dev Callback after a new agreement is updated.\n    * @param superToken The super token used for the agreement.\n    * @param agreementClass The agreement class address.\n    * @param agreementId The agreementId\n    * @param agreementData The agreement data (non-compressed)\n    * @param cbdata The data returned from the before-hook callback.\n    * @param ctx The context data.\n    * @return newCtx The current context of the transaction.\n    *\n    * @custom:note \n    * - State changes is permitted.\n    * - Only revert with a \"reason\" is permitted.\n    */\n    function afterAgreementUpdated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata cbdata,\n        bytes calldata ctx\n    )\n        external\n        returns (bytes memory newCtx);\n\n    /**\n    * @dev Callback before a new agreement is terminated.\n    * @param superToken The super token used for the agreement.\n    * @param agreementClass The agreement class address.\n    * @param agreementId The agreementId\n    * @param agreementData The agreement data (non-compressed)\n    * @param ctx The context data.\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to the after-hook callback.\n    *\n    * @custom:note \n    * - It will be invoked with `staticcall`, no state changes are permitted.\n    * - Revert is not permitted.\n    */\n    function beforeAgreementTerminated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata ctx\n    )\n        external\n        view\n        returns (bytes memory cbdata);\n\n    /**\n    * @dev Callback after a new agreement is terminated.\n    * @param superToken The super token used for the agreement.\n    * @param agreementClass The agreement class address.\n    * @param agreementId The agreementId\n    * @param agreementData The agreement data (non-compressed)\n    * @param cbdata The data returned from the before-hook callback.\n    * @param ctx The context data.\n    * @return newCtx The current context of the transaction.\n    *\n    * @custom:note \n    * - State changes is permitted.\n    * - Revert is not permitted.\n    */\n    function afterAgreementTerminated(\n        ISuperToken superToken,\n        address agreementClass,\n        bytes32 agreementId,\n        bytes calldata agreementData,\n        bytes calldata cbdata,\n        bytes calldata ctx\n    )\n        external\n        returns (bytes memory newCtx);\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperfluidGovernance } from \"./ISuperfluidGovernance.sol\";\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\nimport { ISuperToken } from \"./ISuperToken.sol\";\nimport { ISuperTokenFactory } from \"./ISuperTokenFactory.sol\";\nimport { ISuperAgreement } from \"./ISuperAgreement.sol\";\nimport { ISuperApp } from \"./ISuperApp.sol\";\nimport {\n    BatchOperation,\n    ContextDefinitions,\n    FlowOperatorDefinitions,\n    SuperAppDefinitions,\n    SuperfluidGovernanceConfigs\n} from \"./Definitions.sol\";\nimport { TokenInfo } from \"../tokens/TokenInfo.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC777 } from \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\n\n/**\n * @title Host interface\n * @author Superfluid\n * @notice This is the central contract of the system where super agreement, super app\n * and super token features are connected.\n *\n * The Superfluid host contract is also the entry point for the protocol users,\n * where batch call and meta transaction are provided for UX improvements.\n *\n */\ninterface ISuperfluid {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    // Superfluid Custom Errors\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\n\n    // App Related Custom Errors\n    // uses SuperAppDefinitions' App Jail Reasons as _code\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\n\n    error HOST_INVALID_OR_EXPIRED_SUPER_APP_REGISTRATION_KEY(); // 0x19ab84d1\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\n    error HOST_NO_APP_REGISTRATION_PERMISSIONS();               // 0x5b93ebf0\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\n    error HOST_UNAUTHORIZED_SUPER_APP_FACTORY();                // 0x289533c5\n\n    /**************************************************************************\n     * Time\n     *\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\n     * > Neo: Then why can't I see what happens to her?\n     * > The Oracle: We can never see past the choices we don't understand.\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\n     *************************************************************************/\n\n    function getNow() external view returns (uint256);\n\n    /**************************************************************************\n     * Governance\n     *************************************************************************/\n\n    /**\n     * @dev Get the current governance address of the Superfluid host\n     */\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\n\n    /**\n     * @dev Replace the current governance with a new one\n     */\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\n    /**\n     * @dev Governance replaced event\n     * @param oldGov Address of the old governance contract\n     * @param newGov Address of the new governance contract\n     */\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\n\n    /**************************************************************************\n     * Agreement Whitelisting\n     *************************************************************************/\n\n    /**\n     * @dev Register a new agreement class to the system\n     * @param agreementClassLogic Initial agreement class code\n     *\n     * @custom:modifiers \n     * - onlyGovernance\n     */\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\n    /**\n     * @notice Agreement class registered event\n     * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n     * @param agreementType The agreement type registered\n     * @param code Address of the new agreement\n     */\n    event AgreementClassRegistered(bytes32 agreementType, address code);\n\n    /**\n    * @dev Update code of an agreement class\n    * @param agreementClassLogic New code for the agreement class\n    *\n    * @custom:modifiers \n    *  - onlyGovernance\n    */\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\n    /**\n     * @notice Agreement class updated event\n     * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n     * @param agreementType The agreement type updated\n     * @param code Address of the new agreement\n     */\n    event AgreementClassUpdated(bytes32 agreementType, address code);\n\n    /**\n    * @notice Check if the agreement type is whitelisted\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    */\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\n\n    /**\n    * @dev Check if the agreement class is whitelisted\n    */\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\n\n    /**\n    * @notice Get agreement class\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    */\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\n\n    /**\n    * @dev Map list of the agreement classes using a bitmap\n    * @param bitmap Agreement class bitmap\n    */\n    function mapAgreementClasses(uint256 bitmap)\n        external view\n        returns (ISuperAgreement[] memory agreementClasses);\n\n    /**\n    * @notice Create a new bitmask by adding a agreement class to it\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    * @param bitmap Agreement class bitmap\n    */\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\n        external view\n        returns (uint256 newBitmap);\n\n    /**\n    * @notice Create a new bitmask by removing a agreement class from it\n    * @dev agreementType is the keccak256 hash of: \"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\"\n    * @param bitmap Agreement class bitmap\n    */\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\n        external view\n        returns (uint256 newBitmap);\n\n    /**************************************************************************\n    * Super Token Factory\n    **************************************************************************/\n\n    /**\n     * @dev Get the super token factory\n     * @return factory The factory\n     */\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\n\n    /**\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\n     * @return logic The factory logic\n     */\n    function getSuperTokenFactoryLogic() external view returns (address logic);\n\n    /**\n     * @dev Update super token factory\n     * @param newFactory New factory logic\n     */\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\n    /**\n     * @dev SuperToken factory updated event\n     * @param newFactory Address of the new factory\n     */\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\n\n    /**\n     * @notice Update the super token logic to the latest\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\n     */\n    function updateSuperTokenLogic(ISuperToken token) external;\n    /**\n     * @dev SuperToken logic updated event\n     * @param code Address of the new SuperToken logic\n     */\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\n\n    /**************************************************************************\n     * App Registry\n     *************************************************************************/\n\n    /**\n     * @dev Message sender (must be a contract) declares itself as a super app.\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\n     * because app registration is currently governance permissioned on mainnets.\n     * @param configWord The super app manifest configuration, flags are defined in\n     * `SuperAppDefinitions`\n     */\n    function registerApp(uint256 configWord) external;\n    /**\n     * @dev App registered event\n     * @param app Address of jailed app\n     */\n    event AppRegistered(ISuperApp indexed app);\n\n    /**\n     * @dev Message sender declares itself as a super app.\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\n     * must be the deployer account the registration key was issued for.\n     */\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\n\n    /**\n     * @dev Message sender (must be a contract) declares app as a super app\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\n     */\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\n\n    /**\n     * @dev Query if the app is registered\n     * @param app Super app address\n     */\n    function isApp(ISuperApp app) external view returns(bool);\n\n    /**\n     * @dev Query app callbacklevel\n     * @param app Super app address\n     */\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\n\n    /**\n     * @dev Get the manifest of the super app\n     * @param app Super app address\n     */\n    function getAppManifest(\n        ISuperApp app\n    )\n        external view\n        returns (\n            bool isSuperApp,\n            bool isJailed,\n            uint256 noopMask\n        );\n\n    /**\n     * @dev Query if the app has been jailed\n     * @param app Super app address\n     */\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\n\n    /**\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\n     * @param targetApp The target super app address\n     */\n    function allowCompositeApp(ISuperApp targetApp) external;\n\n    /**\n     * @dev Query if source app is allowed to call the target app as downstream app\n     * @param app Super app address\n     * @param targetApp The target super app address\n     */\n    function isCompositeAppAllowed(\n        ISuperApp app,\n        ISuperApp targetApp\n    )\n        external view\n        returns (bool isAppAllowed);\n\n    /**************************************************************************\n     * Agreement Framework\n     *\n     * Agreements use these function to trigger super app callbacks, updates\n     * app credit and charge gas fees.\n     *\n     * These functions can only be called by registered agreements.\n     *************************************************************************/\n\n    /**\n     * @dev (For agreements) StaticCall the app before callback\n     * @param  app               The super app.\n     * @param  callData          The call data sending to the super app.\n     * @param  isTermination     Is it a termination callback?\n     * @param  ctx               Current ctx, it will be validated.\n     * @return cbdata            Data returned from the callback.\n     */\n    function callAppBeforeCallback(\n        ISuperApp app,\n        bytes calldata callData,\n        bool isTermination,\n        bytes calldata ctx\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns(bytes memory cbdata);\n\n    /**\n     * @dev (For agreements) Call the app after callback\n     * @param  app               The super app.\n     * @param  callData          The call data sending to the super app.\n     * @param  isTermination     Is it a termination callback?\n     * @param  ctx               Current ctx, it will be validated.\n     * @return newCtx            The current context of the transaction.\n     */\n    function callAppAfterCallback(\n        ISuperApp app,\n        bytes calldata callData,\n        bool isTermination,\n        bytes calldata ctx\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns(bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Create a new callback stack\n     * @param  ctx                     The current ctx, it will be validated.\n     * @param  app                     The super app.\n     * @param  appCreditGranted        App credit granted so far.\n     * @param  appCreditUsed           App credit used so far.\n     * @return newCtx                  The current context of the transaction.\n     */\n    function appCallbackPush(\n        bytes calldata ctx,\n        ISuperApp app,\n        uint256 appCreditGranted,\n        int256 appCreditUsed,\n        ISuperfluidToken appCreditToken\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Pop from the current app callback stack\n     * @param  ctx                     The ctx that was pushed before the callback stack.\n     * @param  appCreditUsedDelta      App credit used by the app.\n     * @return newCtx                  The current context of the transaction.\n     *\n     * @custom:security\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\n     */\n    function appCallbackPop(\n        bytes calldata ctx,\n        int256 appCreditUsedDelta\n    )\n        external\n        // onlyAgreement\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Use app credit.\n     * @param  ctx                      The current ctx, it will be validated.\n     * @param  appCreditUsedMore        See app credit for more details.\n     * @return newCtx                   The current context of the transaction.\n     */\n    function ctxUseCredit(\n        bytes calldata ctx,\n        int256 appCreditUsedMore\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev (For agreements) Jail the app.\n     * @param  app                     The super app.\n     * @param  reason                  Jail reason code.\n     * @return newCtx                  The current context of the transaction.\n     */\n    function jailApp(\n        bytes calldata ctx,\n        ISuperApp app,\n        uint256 reason\n    )\n        external\n        // onlyAgreement\n        // assertValidCtx(ctx)\n        returns (bytes memory newCtx);\n\n    /**\n     * @dev Jail event for the app\n     * @param app Address of jailed app\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\n     */\n    event Jail(ISuperApp indexed app, uint256 reason);\n\n    /**************************************************************************\n     * Contextless Call Proxies\n     *\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\n     * with agreements or apps.\n     *\n     * NOTE: The contextual call data should be generated using\n     * abi.encodeWithSelector. The context parameter should be set to \"0x\",\n     * an empty bytes array as a placeholder to be replaced by the host\n     * contract.\n     *************************************************************************/\n\n     /**\n      * @dev Call agreement function\n      * @param agreementClass The agreement address you are calling\n      * @param callData The contextual call data with placeholder ctx\n      * @param userData Extra user data being sent to the super app callbacks\n      */\n     function callAgreement(\n         ISuperAgreement agreementClass,\n         bytes calldata callData,\n         bytes calldata userData\n     )\n        external\n        //cleanCtx\n        //isAgreement(agreementClass)\n        returns(bytes memory returnedData);\n\n    /**\n     * @notice Call app action\n     * @dev Main use case is calling app action in a batch call via the host\n     * @param callData The contextual call data\n     *\n     * @custom:note See \"Contextless Call Proxies\" above for more about contextual call data.\n     */\n    function callAppAction(\n        ISuperApp app,\n        bytes calldata callData\n    )\n        external\n        //cleanCtx\n        //isAppActive(app)\n        //isValidAppAction(callData)\n        returns(bytes memory returnedData);\n\n    /**************************************************************************\n     * Contextual Call Proxies and Context Utilities\n     *\n     * For apps, they must use context they receive to interact with\n     * agreements or apps.\n     *\n     * The context changes must be saved and returned by the apps in their\n     * callbacks always, any modification to the context will be detected and\n     * the violating app will be jailed.\n     *************************************************************************/\n\n    /**\n     * @dev Context Struct\n     *\n     * @custom:note on backward compatibility:\n     * - Non-dynamic fields are padded to 32bytes and packed\n     * - Dynamic fields are referenced through a 32bytes offset to their \"parents\" field (or root)\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\n     *    - non-dynamic fields will be parsed at the same memory location,\n     *    - and dynamic fields will simply have a greater offset than it was.\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\n     */\n    struct Context {\n        //\n        // Call context\n        //\n        // app callback level\n        uint8 appCallbackLevel;\n        // type of call\n        uint8 callType;\n        // the system timestamp\n        uint256 timestamp;\n        // The intended message sender for the call\n        address msgSender;\n\n        //\n        // Callback context\n        //\n        // For callbacks it is used to know which agreement function selector is called\n        bytes4 agreementSelector;\n        // User provided data for app callbacks\n        bytes userData;\n\n        //\n        // App context\n        //\n        // app credit granted\n        uint256 appCreditGranted;\n        // app credit wanted by the app callback\n        uint256 appCreditWantedDeprecated;\n        // app credit used, allowing negative values over a callback session\n        // the appCreditUsed value over a callback sessions is calculated with:\n        // existing flow data owed deposit + sum of the callback agreements\n        // deposit deltas \n        // the final value used to modify the state is determined by the\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes \n        // the appCreditUsed value reached in the callback session and the app\n        // credit granted\n        int256 appCreditUsed;\n        // app address\n        address appAddress;\n        // app credit in super token\n        ISuperfluidToken appCreditToken;\n    }\n\n    function callAgreementWithContext(\n        ISuperAgreement agreementClass,\n        bytes calldata callData,\n        bytes calldata userData,\n        bytes calldata ctx\n    )\n        external\n        // requireValidCtx(ctx)\n        // onlyAgreement(agreementClass)\n        returns (bytes memory newCtx, bytes memory returnedData);\n\n    function callAppActionWithContext(\n        ISuperApp app,\n        bytes calldata callData,\n        bytes calldata ctx\n    )\n        external\n        // requireValidCtx(ctx)\n        // isAppActive(app)\n        returns (bytes memory newCtx);\n\n    function decodeCtx(bytes memory ctx)\n        external pure\n        returns (Context memory context);\n\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\n\n    /**************************************************************************\n    * Batch call\n    **************************************************************************/\n    /**\n     * @dev Batch operation data\n     */\n    struct Operation {\n        // Operation type. Defined in BatchOperation (Definitions.sol)\n        uint32 operationType;\n        // Operation target\n        address target;\n        // Data specific to the operation\n        bytes data;\n    }\n\n    /**\n     * @dev Batch call function\n     * @param operations Array of batch operations\n     */\n    function batchCall(Operation[] calldata operations) external;\n\n    /**\n     * @dev Batch call function for trusted forwarders (EIP-2771)\n     * @param operations Array of batch operations\n     */\n    function forwardBatchCall(Operation[] calldata operations) external;\n\n    /**************************************************************************\n     * Function modifiers for access control and parameter validations\n     *\n     * While they cannot be explicitly stated in function definitions, they are\n     * listed in function definition comments instead for clarity.\n     *\n     * TODO: turning these off because solidity-coverage doesn't like it\n     *************************************************************************/\n\n     /* /// @dev The current superfluid context is clean.\n     modifier cleanCtx() virtual;\n\n     /// @dev Require the ctx being valid.\n     modifier requireValidCtx(bytes memory ctx) virtual;\n\n     /// @dev Assert the ctx being valid.\n     modifier assertValidCtx(bytes memory ctx) virtual;\n\n     /// @dev The agreement is a listed agreement.\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\n\n     // onlyGovernance\n\n     /// @dev The msg.sender must be a listed agreement.\n     modifier onlyAgreement() virtual;\n\n     /// @dev The app is registered and not jailed.\n     modifier isAppActive(ISuperApp app) virtual; */\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"./ISuperAgreement.sol\";\nimport { ISuperToken } from \"./ISuperToken.sol\";\nimport { ISuperfluidToken  } from \"./ISuperfluidToken.sol\";\nimport { ISuperfluid } from \"./ISuperfluid.sol\";\n\n\n/**\n * @title Superfluid governance interface\n * @author Superfluid\n */\ninterface ISuperfluidGovernance {\n    \n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SF_GOV_ARRAYS_NOT_SAME_LENGTH();                  // 0x27743aa6\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\n\n    /**\n     * @dev Replace the current governance with a new governance\n     */\n    function replaceGovernance(\n        ISuperfluid host,\n        address newGov) external;\n\n    /**\n     * @dev Register a new agreement class\n     */\n    function registerAgreementClass(\n        ISuperfluid host,\n        address agreementClass) external;\n\n    /**\n     * @dev Update logics of the contracts\n     *\n     * @custom:note \n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\n     */\n    function updateContracts(\n        ISuperfluid host,\n        address hostNewLogic,\n        address[] calldata agreementClassNewLogics,\n        address superTokenFactoryNewLogic\n    ) external;\n\n    /**\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\n     */\n    function batchUpdateSuperTokenLogic(\n        ISuperfluid host,\n        ISuperToken[] calldata tokens) external;\n    \n    /**\n     * @dev Set configuration as address value\n     */\n    function setConfig(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key,\n        address value\n    ) external;\n    \n    /**\n     * @dev Set configuration as uint256 value\n     */\n    function setConfig(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key,\n        uint256 value\n    ) external;\n\n    /**\n     * @dev Clear configuration\n     */\n    function clearConfig(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key\n    ) external;\n\n    /**\n     * @dev Get configuration as address value\n     */\n    function getConfigAsAddress(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key) external view returns (address value);\n\n    /**\n     * @dev Get configuration as uint256 value\n     */\n    function getConfigAsUint256(\n        ISuperfluid host,\n        ISuperfluidToken superToken,\n        bytes32 key) external view returns (uint256 value);\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperAgreement } from \"./ISuperAgreement.sol\";\n\n/**\n * @title Superfluid token interface\n * @author Superfluid\n */\ninterface ISuperfluidToken {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\n\n    /**************************************************************************\n     * Basic information\n     *************************************************************************/\n\n    /**\n     * @dev Get superfluid host contract address\n     */\n    function getHost() external view returns(address host);\n\n    /**\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\n     *\n     * @custom:note \n     * - version: 1\n     * - liquidationType key:\n     *    - 0 = reward account receives reward (PIC period)\n     *    - 1 = liquidator account receives reward (Pleb period)\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\n     */\n    struct LiquidationTypeData {\n        uint256 version;\n        uint8 liquidationType;\n    }\n\n    /**************************************************************************\n     * Real-time balance functions\n     *************************************************************************/\n\n    /**\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\n    * @param account for the query\n    * @param timestamp Time of balance\n    * @return availableBalance Real-time balance\n    * @return deposit Account deposit\n    * @return owedDeposit Account owed Deposit\n    */\n    function realtimeBalanceOf(\n       address account,\n       uint256 timestamp\n    )\n        external view\n        returns (\n            int256 availableBalance,\n            uint256 deposit,\n            uint256 owedDeposit);\n\n    /**\n     * @notice Calculate the realtime balance given the current host.getNow() value\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\n     * @param account for the query\n     * @return availableBalance Real-time balance\n     * @return deposit Account deposit\n     * @return owedDeposit Account owed Deposit\n     */\n    function realtimeBalanceOfNow(\n       address account\n    )\n        external view\n        returns (\n            int256 availableBalance,\n            uint256 deposit,\n            uint256 owedDeposit,\n            uint256 timestamp);\n\n    /**\n    * @notice Check if account is critical\n    * @dev A critical account is when availableBalance < 0\n    * @param account The account to check\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\n    * @return isCritical Whether the account is critical\n    */\n    function isAccountCritical(\n        address account,\n        uint256 timestamp\n    )\n        external view\n        returns(bool isCritical);\n\n    /**\n    * @notice Check if account is critical now (current host.getNow())\n    * @dev A critical account is when availableBalance < 0\n    * @param account The account to check\n    * @return isCritical Whether the account is critical\n    */\n    function isAccountCriticalNow(\n        address account\n    )\n        external view\n        returns(bool isCritical);\n\n    /**\n     * @notice Check if account is solvent\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\n     * @param account The account to check\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\n     * @return isSolvent True if the account is solvent, false otherwise\n     */\n    function isAccountSolvent(\n        address account,\n        uint256 timestamp\n    )\n        external view\n        returns(bool isSolvent);\n\n    /**\n     * @notice Check if account is solvent now\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\n     * @param account The account to check\n     * @return isSolvent True if the account is solvent, false otherwise\n     */\n    function isAccountSolventNow(\n        address account\n    )\n        external view\n        returns(bool isSolvent);\n\n    /**\n    * @notice Get a list of agreements that is active for the account\n    * @dev An active agreement is one that has state for the account\n    * @param account Account to query\n    * @return activeAgreements List of accounts that have non-zero states for the account\n    */\n    function getAccountActiveAgreements(address account)\n       external view\n       returns(ISuperAgreement[] memory activeAgreements);\n\n\n   /**************************************************************************\n    * Super Agreement hosting functions\n    *************************************************************************/\n\n    /**\n     * @dev Create a new agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    function createAgreement(\n        bytes32 id,\n        bytes32[] calldata data\n    )\n        external;\n    /**\n     * @dev Agreement created event\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    event AgreementCreated(\n        address indexed agreementClass,\n        bytes32 id,\n        bytes32[] data\n    );\n\n    /**\n     * @dev Get data of the agreement\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @return data Data of the agreement\n     */\n    function getAgreementData(\n        address agreementClass,\n        bytes32 id,\n        uint dataLength\n    )\n        external view\n        returns(bytes32[] memory data);\n\n    /**\n     * @dev Create a new agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    function updateAgreementData(\n        bytes32 id,\n        bytes32[] calldata data\n    )\n        external;\n    /**\n     * @dev Agreement updated event\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param data Agreement data\n     */\n    event AgreementUpdated(\n        address indexed agreementClass,\n        bytes32 id,\n        bytes32[] data\n    );\n\n    /**\n     * @dev Close the agreement\n     * @param id Agreement ID\n     */\n    function terminateAgreement(\n        bytes32 id,\n        uint dataLength\n    )\n        external;\n    /**\n     * @dev Agreement terminated event\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     */\n    event AgreementTerminated(\n        address indexed agreementClass,\n        bytes32 id\n    );\n\n    /**\n     * @dev Update agreement state slot\n     * @param account Account to be updated\n     *\n     * @custom:note \n     * - To clear the storage out, provide zero-ed array of intended length\n     */\n    function updateAgreementStateSlot(\n        address account,\n        uint256 slotId,\n        bytes32[] calldata slotData\n    )\n        external;\n    /**\n     * @dev Agreement account state updated event\n     * @param agreementClass Contract address of the agreement\n     * @param account Account updated\n     * @param slotId slot id of the agreement state\n     */\n    event AgreementStateUpdated(\n        address indexed agreementClass,\n        address indexed account,\n        uint256 slotId\n    );\n\n    /**\n     * @dev Get data of the slot of the state of an agreement\n     * @param agreementClass Contract address of the agreement\n     * @param account Account to query\n     * @param slotId slot id of the state\n     * @param dataLength length of the state data\n     */\n    function getAgreementStateSlot(\n        address agreementClass,\n        address account,\n        uint256 slotId,\n        uint dataLength\n    )\n        external view\n        returns (bytes32[] memory slotData);\n\n    /**\n     * @notice Settle balance from an account by the agreement\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\n     * @param account Account to query.\n     * @param delta Amount of balance delta to be settled\n     *\n     * @custom:modifiers \n     *  - onlyAgreement\n     */\n    function settleBalance(\n        address account,\n        int256 delta\n    )\n        external;\n\n    /**\n     * @dev Make liquidation payouts (v2)\n     * @param id Agreement ID\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\n     * @param liquidatorAccount Address of the executor of the liquidation\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\n     * @param targetAccount Account to be liquidated\n     * @param rewardAmount The amount the rewarded account will receive\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\n     *\n     * @custom:note \n     * - If a bailout is required (bailoutAmount > 0)\n     *   - the actual reward (single deposit) goes to the executor,\n     *   - while the reward account becomes the bailout account\n     *   - total bailout include: bailout amount + reward amount\n     *   - the targetAccount will be bailed out\n     * - If a bailout is not required\n     *   - the targetAccount will pay the rewardAmount\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\n     *\n     * @custom:modifiers \n     *  - onlyAgreement\n     */\n    function makeLiquidationPayoutsV2\n    (\n        bytes32 id,\n        bytes memory liquidationTypeData,\n        address liquidatorAccount,\n        bool useDefaultRewardAccount,\n        address targetAccount,\n        uint256 rewardAmount,\n        int256 targetAccountBalanceDelta\n    ) external;\n    /**\n     * @dev Agreement liquidation event v2 (including agent account)\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param liquidatorAccount Address of the executor of the liquidation\n     * @param targetAccount Account of the stream sender\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\n     * @param rewardAmount The amount the reward recipient account balance should change by\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\n     *\n     * @custom:note \n     * Reward account rule:\n     * - if the agreement is liquidated during the PIC period\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\n     *   - the targetAccount will pay for the rewardAmount\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\n     *   - the targetAccount will pay for the rewardAmount\n     * - if the targetAccount is insolvent\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\n     *   - the targetAccount will receive the bailoutAmount\n     */\n    event AgreementLiquidatedV2(\n        address indexed agreementClass,\n        bytes32 id,\n        address indexed liquidatorAccount,\n        address indexed targetAccount,\n        address rewardAmountReceiver,\n        uint256 rewardAmount,\n        int256 targetAccountBalanceDelta,\n        bytes liquidationTypeData\n    );\n\n    /**************************************************************************\n     * Function modifiers for access control and parameter validations\n     *\n     * While they cannot be explicitly stated in function definitions, they are\n     * listed in function definition comments instead for clarity.\n     *\n     * NOTE: solidity-coverage not supporting it\n     *************************************************************************/\n\n     /// @dev The msg.sender must be host contract\n     //modifier onlyHost() virtual;\n\n    /// @dev The msg.sender must be a listed agreement.\n    //modifier onlyAgreement() virtual;\n\n    /**************************************************************************\n     * DEPRECATED\n     *************************************************************************/\n\n    /**\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param penaltyAccount Account of the agreement to be penalized\n     * @param rewardAccount Account that collect the reward\n     * @param rewardAmount Amount of liquidation reward\n     *\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\n     */\n    event AgreementLiquidated(\n        address indexed agreementClass,\n        bytes32 id,\n        address indexed penaltyAccount,\n        address indexed rewardAccount,\n        uint256 rewardAmount\n    );\n\n    /**\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\n     * @param bailoutAccount Account that bailout the penalty account\n     * @param bailoutAmount Amount of account bailout\n     *\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\n     */\n    event Bailout(\n        address indexed bailoutAccount,\n        uint256 bailoutAmount\n    );\n\n    /**\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\n     * @param agreementClass Contract address of the agreement\n     * @param id Agreement ID\n     * @param penaltyAccount Account of the agreement to be penalized\n     * @param bondAccount Account that collect the reward or bailout accounts\n     * @param rewardAmount Amount of liquidation reward\n     * @param bailoutAmount Amount of liquidation bailouot\n     *\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\n     *\n     * @custom:note \n     * Reward account rule:\n     * - if bailout is equal to 0, then\n     *   - the bondAccount will get the rewardAmount,\n     *   - the penaltyAccount will pay for the rewardAmount.\n     * - if bailout is larger than 0, then\n     *   - the liquidatorAccount will get the rewardAmouont,\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\n     */\n    event AgreementLiquidatedBy(\n        address liquidatorAccount,\n        address indexed agreementClass,\n        bytes32 id,\n        address indexed penaltyAccount,\n        address indexed bondAccount,\n        uint256 rewardAmount,\n        uint256 bailoutAmount\n    );\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperfluid } from \"./ISuperfluid.sol\";\nimport { ISuperfluidToken } from \"./ISuperfluidToken.sol\";\nimport { TokenInfo } from \"../tokens/TokenInfo.sol\";\nimport { IERC777 } from \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\n * @author Superfluid\n */\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\n    error SUPER_TOKEN_ONLY_HOST();                               // 0x98f73704\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\n\n    /**\n     * @dev Initialize the contract\n     */\n    function initialize(\n        IERC20 underlyingToken,\n        uint8 underlyingDecimals,\n        string calldata n,\n        string calldata s\n    ) external;\n\n    /**************************************************************************\n    * TokenInfo & ERC777\n    *************************************************************************/\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * @custom:note SuperToken always uses 18 decimals.\n     *\n     * This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external view override(TokenInfo) returns (uint8);\n\n    /**************************************************************************\n    * ERC20 & ERC777\n    *************************************************************************/\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\n\n    /**************************************************************************\n    * ERC20\n    *************************************************************************/\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\n     *\n     * @custom:emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\n     *         zero by default.\n     *\n     * @notice This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\n     *\n     * @custom:note Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * @custom:emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     *         allowance mechanism. `amount` is then deducted from the caller's\n     *         allowance.\n     *\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\n     *\n     * @custom:emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * @custom:emits an {Approval} event indicating the updated allowance.\n     *\n     * @custom:requirements \n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * @custom:emits an {Approval} event indicating the updated allowance.\n     *\n     * @custom:requirements \n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    /**************************************************************************\n    * ERC777\n    *************************************************************************/\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     *         means all token operations (creation, movement and destruction) must have\n     *         amounts that are a multiple of this number.\n     *\n     * @custom:note For super token contracts, this value is always 1\n     */\n    function granularity() external view override(IERC777) returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\n     *      the corresponding functions will be called with `data` and empty\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * @custom:emits a {Sent} event.\n     *\n     * @custom:requirements \n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply and transfers the underlying token to the caller's account.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * @custom:emits a {Burned} event.\n     *\n     * @custom:requirements \n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * @custom:emits an {AuthorizedOperator} event.\n     *\n     * @custom:requirements \n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external override(IERC777);\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * @custom:emits a {RevokedOperator} event.\n     *\n     * @custom:requirements \n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external override(IERC777);\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * @custom:emits a {Sent} event.\n     *\n     * @custom:requirements \n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external override(IERC777);\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * @custom:emits a {Burned} event.\n     *\n     * @custom:requirements \n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external override(IERC777);\n\n    /**************************************************************************\n     * SuperToken custom token functions\n     *************************************************************************/\n\n    /**\n     * @dev Mint new tokens for the account\n     *\n     * @custom:modifiers \n     *  - onlySelf\n     */\n    function selfMint(\n        address account,\n        uint256 amount,\n        bytes memory userData\n    ) external;\n\n   /**\n    * @dev Burn existing tokens for the account\n    *\n    * @custom:modifiers \n    *  - onlySelf\n    */\n   function selfBurn(\n       address account,\n       uint256 amount,\n       bytes memory userData\n   ) external;\n\n   /**\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\n    * spend tokens of `sender`.\n    *\n    * @custom:modifiers \n    *  - onlySelf\n    */\n   function selfTransferFrom(\n        address sender,\n        address spender,\n        address recipient,\n        uint256 amount\n   ) external;\n\n   /**\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\n    * `account`.\n    *\n    * @custom:modifiers \n    *  - onlySelf\n    */\n   function selfApproveFor(\n        address account,\n        address spender,\n        uint256 amount\n   ) external;\n\n    /**************************************************************************\n     * SuperToken extra functions\n     *************************************************************************/\n\n    /**\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\n     */\n    function transferAll(address recipient) external;\n\n    /**************************************************************************\n     * ERC20 wrapping\n     *************************************************************************/\n\n    /**\n     * @dev Return the underlying token contract\n     * @return tokenAddr Underlying token address\n     */\n    function getUnderlyingToken() external view returns(address tokenAddr);\n\n    /**\n     * @dev Upgrade ERC20 to SuperToken.\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\n     *\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\n     * function you should `approve` this contract\n     */\n    function upgrade(uint256 amount) external;\n\n    /**\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\n     * @param to The account to receive upgraded tokens\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\n     * @param data User data for the TokensRecipient callback\n     *\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\n     * function you should `approve` this contract\n     * \n     * @custom:warning\n     * - there is potential of reentrancy IF the \"to\" account is a registered ERC777 recipient.\n     * @custom:requirements \n     * - if `data` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient otherwise it reverts.\n     */\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Token upgrade event\n     * @param account Account where tokens are upgraded to\n     * @param amount Amount of tokens upgraded (in 18 decimals)\n     */\n    event TokenUpgraded(\n        address indexed account,\n        uint256 amount\n    );\n\n    /**\n     * @dev Downgrade SuperToken to ERC20.\n     * @dev It will call transfer to send tokens\n     * @param amount Number of tokens to be downgraded\n     */\n    function downgrade(uint256 amount) external;\n\n    /**\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\n     * @param to The account to receive downgraded tokens\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\n     */\n    function downgradeTo(address to, uint256 amount) external;\n\n    /**\n     * @dev Token downgrade event\n     * @param account Account whose tokens are downgraded\n     * @param amount Amount of tokens downgraded\n     */\n    event TokenDowngraded(\n        address indexed account,\n        uint256 amount\n    );\n\n    /**************************************************************************\n    * Batch Operations\n    *************************************************************************/\n\n    /**\n    * @dev Perform ERC20 approve by host contract.\n    * @param account The account owner to be approved.\n    * @param spender The spender of account owner's funds.\n    * @param amount Number of tokens to be approved.\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationApprove(\n        address account,\n        address spender,\n        uint256 amount\n    ) external;\n\n    /**\n    * @dev Perform ERC20 transferFrom by host contract.\n    * @param account The account to spend sender's funds.\n    * @param spender The account where the funds is sent from.\n    * @param recipient The recipient of the funds.\n    * @param amount Number of tokens to be transferred.\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationTransferFrom(\n        address account,\n        address spender,\n        address recipient,\n        uint256 amount\n    ) external;\n\n    /**\n    * @dev Perform ERC777 send by host contract.\n    * @param spender The account where the funds is sent from.\n    * @param recipient The recipient of the funds.\n    * @param amount Number of tokens to be transferred.\n    * @param data Arbitrary user inputted data\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationSend(\n        address spender,\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) external;\n\n    /**\n    * @dev Upgrade ERC20 to SuperToken by host contract.\n    * @param account The account to be changed.\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationUpgrade(address account, uint256 amount) external;\n\n    /**\n    * @dev Downgrade ERC20 to SuperToken by host contract.\n    * @param account The account to be changed.\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\n    *\n    * @custom:modifiers \n    *  - onlyHost\n    */\n    function operationDowngrade(address account, uint256 amount) external;\n\n\n    /**************************************************************************\n    * Function modifiers for access control and parameter validations\n    *\n    * While they cannot be explicitly stated in function definitions, they are\n    * listed in function definition comments instead for clarity.\n    *\n    * NOTE: solidity-coverage not supporting it\n    *************************************************************************/\n\n    /// @dev The msg.sender must be the contract itself\n    //modifier onlySelf() virtual\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { ISuperToken } from \"./ISuperToken.sol\";\n\nimport {\n    IERC20,\n    ERC20WithTokenInfo\n} from \"../tokens/ERC20WithTokenInfo.sol\";\n\n/**\n * @title Super token factory interface\n * @author Superfluid\n */\ninterface ISuperTokenFactory {\n\n    /**************************************************************************\n     * Errors\n     *************************************************************************/\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS(); // 0x91d67972\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST(); // 0x872cac48\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();  // 0x1b39b9b4\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();      // 0x478b8e83\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();   // 0x305c9e82\n\n    /**\n     * @dev Get superfluid host contract address\n     */\n    function getHost() external view returns(address host);\n\n    /// @dev Initialize the contract\n    function initialize() external;\n\n    /**\n     * @dev Get the current super token logic used by the factory\n     */\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\n\n    /**\n     * @dev Upgradability modes\n     */\n    enum Upgradability {\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\n        NON_UPGRADABLE,\n        /// Upgradable through `host.updateSuperTokenLogic` operation\n        SEMI_UPGRADABLE,\n        /// Always using the latest super token logic\n        FULL_UPGRADABLE\n    }\n\n    /**\n     * @notice Create new super token wrapper for the underlying ERC20 token\n     * @param underlyingToken Underlying ERC20 token\n     * @param underlyingDecimals Underlying token decimals\n     * @param upgradability Upgradability mode\n     * @param name Super token name\n     * @param symbol Super token symbol\n     * @return superToken The deployed and initialized wrapper super token\n     */\n    function createERC20Wrapper(\n        IERC20 underlyingToken,\n        uint8 underlyingDecimals,\n        Upgradability upgradability,\n        string calldata name,\n        string calldata symbol\n    )\n        external\n        returns (ISuperToken superToken);\n\n    /**\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\n     * @param underlyingToken Underlying ERC20 token\n     * @param upgradability Upgradability mode\n     * @param name Super token name\n     * @param symbol Super token symbol\n     * @return superToken The deployed and initialized wrapper super token\n     * NOTE:\n     * - It assumes token provide the .decimals() function\n     */\n    function createERC20Wrapper(\n        ERC20WithTokenInfo underlyingToken,\n        Upgradability upgradability,\n        string calldata name,\n        string calldata symbol\n    )\n        external\n        returns (ISuperToken superToken);\n\n    /**\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\n     * @param _underlyingToken Underlying ERC20 token\n     * @return ISuperToken the created supertoken\n     */\n    function createCanonicalERC20Wrapper(ERC20WithTokenInfo _underlyingToken)\n        external\n        returns (ISuperToken);\n\n    /**\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\n     * @param _underlyingToken Underlying ERC20 token address\n     * @return superTokenAddress Super token address\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\n     */\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\n        external\n        view\n        returns (address superTokenAddress, bool isDeployed);\n\n    /**\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\n     * @dev We return the address if it exists and the zero address otherwise\n     * @param _underlyingTokenAddress Underlying ERC20 token address\n     * @return superTokenAddress Super token address\n     */\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\n        external\n        view\n        returns (address superTokenAddress);\n\n    /**\n     * @dev Creates a new custom super token\n     * @param customSuperTokenProxy address of the custom supertoken proxy\n     */\n    function initializeCustomSuperToken(\n        address customSuperTokenProxy\n    )\n        external;\n\n    /**\n      * @dev Super token logic created event\n      * @param tokenLogic Token logic address\n      */\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\n\n    /**\n      * @dev Super token created event\n      * @param token Newly created super token address\n      */\n    event SuperTokenCreated(ISuperToken indexed token);\n\n    /**\n      * @dev Custom super token created event\n      * @param token Newly created custom super token address\n      */\n    event CustomSuperTokenCreated(ISuperToken indexed token);\n\n}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TokenInfo } from \"./TokenInfo.sol\";\n\n/**\n * @title ERC20 token with token info interface\n * @author Superfluid\n * @dev Using abstract contract instead of interfaces because old solidity\n *      does not support interface inheriting other interfaces\n * solhint-disable-next-line no-empty-blocks\n *\n */\n// solhint-disable-next-line no-empty-blocks\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.16;\n\nimport { ISuperToken } from \"../superfluid/ISuperToken.sol\";\n\n\n/**\n * @title Super ETH (SETH) custom token interface\n * @author Superfluid\n */\ninterface ISETHCustom {\n    // using native token\n    function upgradeByETH() external payable;\n    function upgradeByETHTo(address to) external payable;\n    function downgradeToETH(uint wad) external;\n}\n\n/**\n * @title Super ETH (SETH) full interface\n * @author Superfluid\n */\n// solhint-disable-next-line no-empty-blocks\ninterface ISETH is ISETHCustom, ISuperToken {}\n"
    },
    "@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol": {
      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity >= 0.8.4;\n\n/**\n * @title ERC20 token info interface\n * @author Superfluid\n * @dev ERC20 standard interface does not specify these functions, but\n *      often the token implementations have them.\n */\ninterface TokenInfo {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'STE');\n    }\n}\n"
    },
    "contracts/SuperfluidStream.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\npragma abicoder v2;\r\n\r\nimport {ISuperfluid} from \"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\";\r\nimport {IConstantFlowAgreementV1} from \"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\";\r\nimport {ISuperToken} from \"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\";\r\nimport {ISETHCustom} from \"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\";\r\nimport {CFAv1Library} from \"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\";\r\nimport {SuperTokenV1Library} from \"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\r\nimport \"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\";\r\n\r\nerror SuperfluidStream__NotEnoughSuperToken(\r\n    address sender,\r\n    uint256 superAmount\r\n);\r\nerror SuperfluidStream__NoSuperTokenToDowngrade();\r\nerror SuperfluidStream__FlowHadBeenCreatedToThisReceiver(\r\n    address sender,\r\n    uint superAmount\r\n);\r\n\r\ncontract SuperfluidStream is ReentrancyGuard, AutomationCompatibleInterface {\r\n    /**Type Variables */\r\n    enum SwapState {\r\n        OPEN,\r\n        PENDING,\r\n        CLOSE\r\n    }\r\n\r\n    struct SwappingAddress {\r\n        address from;\r\n        address to;\r\n    }\r\n\r\n    /**State Variable */\r\n    using CFAv1Library for CFAv1Library.InitData;\r\n    CFAv1Library.InitData public cfaLib;\r\n    using SuperTokenV1Library for ISuperToken;\r\n\r\n    ISuperToken private immutable i_tokenAddress;\r\n    ISuperToken private immutable i_fDAIAddress;\r\n    ISwapRouter public immutable i_swapRouter;\r\n    SwapState private s_swapState;\r\n    uint24 public constant POOL_FEE = 3000;\r\n    uint256 public immutable i_interval;\r\n    uint256 public lastTimeStamp;\r\n    uint256 public swapperSwapAmount;\r\n    address public swapFrom;\r\n    address public swapTo;\r\n    uint256 public s_swapTime;\r\n    uint256 public s_duration;\r\n\r\n    mapping(address => uint256) private s_senderSuperBalance;\r\n    mapping(address => mapping(uint256 => SwappingAddress))\r\n        private s_swappingAmount;\r\n\r\n    constructor(\r\n        ISuperfluid host,\r\n        ISuperToken tokenAddress,\r\n        ISwapRouter _swapRouter,\r\n        uint256 interval,\r\n        ISuperToken fDAIAddress\r\n    ) {\r\n        i_tokenAddress = tokenAddress;\r\n        i_swapRouter = _swapRouter;\r\n        i_interval = interval;\r\n        s_swapState = SwapState.CLOSE;\r\n        i_fDAIAddress = fDAIAddress;\r\n\r\n        cfaLib = CFAv1Library.InitData(\r\n            host,\r\n            //here, we are deriving the address of the CFA using the host contract\r\n            IConstantFlowAgreementV1(\r\n                address(\r\n                    host.getAgreementClass(\r\n                        keccak256(\r\n                            \"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\"\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    function checkUpkeep(\r\n        bytes memory /* checkData */\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (bool upkeepNeeded, bytes memory /* performData */)\r\n    {\r\n        bool isSwapOpen = (SwapState.OPEN == s_swapState);\r\n        bool isSwapPending = (SwapState.PENDING == s_swapState);\r\n        bool timePassed = (block.timestamp - lastTimeStamp) >= i_interval;\r\n        upkeepNeeded = (isSwapOpen || isSwapPending) && timePassed;\r\n    }\r\n\r\n    function enterSwap() external {\r\n        s_swapState = SwapState.OPEN;\r\n        lastTimeStamp = block.timestamp;\r\n    }\r\n\r\n    function performUpkeep(bytes calldata /* performData */) external override {\r\n        (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n        s_swapTime += 1;\r\n        if (s_swapTime < s_duration) {\r\n            if (upkeepNeeded) {\r\n                swap(swapperSwapAmount, swapFrom, swapTo, s_duration);\r\n                lastTimeStamp = block.timestamp;\r\n            }\r\n            s_swapState = SwapState.PENDING;\r\n        }\r\n        if (s_swapTime == s_duration) {\r\n            s_swapState = SwapState.CLOSE;\r\n        }\r\n    }\r\n\r\n    function swap(\r\n        uint256 amountIn,\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint256 duration\r\n    ) public returns (uint256 amountOut) {\r\n        s_swappingAmount[msg.sender][amountIn] = SwappingAddress(\r\n            tokenIn,\r\n            tokenOut\r\n        );\r\n        swapperSwapAmount = amountIn;\r\n        swapFrom = tokenIn;\r\n        swapTo = tokenOut;\r\n        s_duration = duration;\r\n        TransferHelper.safeApprove(tokenIn, address(i_swapRouter), amountIn);\r\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\r\n            .ExactInputSingleParams({\r\n                tokenIn: tokenIn,\r\n                tokenOut: tokenOut,\r\n                fee: POOL_FEE,\r\n                recipient: address(this),\r\n                deadline: block.timestamp, //make sure the swap wont go on forever as the price of token might shift\r\n                amountIn: amountIn,\r\n                amountOutMinimum: 0,\r\n                sqrtPriceLimitX96: 0\r\n            });\r\n        amountOut = i_swapRouter.exactInputSingle(params);\r\n    }\r\n\r\n    function upgradeMATIC() external payable nonReentrant {\r\n        if (msg.value <= 0) {\r\n            revert SuperfluidStream__NotEnoughSuperToken(msg.sender, msg.value);\r\n        }\r\n\r\n        ISETHCustom(address(i_tokenAddress)).upgradeByETHTo{value: msg.value}(\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function downgradeMATICx(uint256 wad) external {\r\n        ISETHCustom(address(i_tokenAddress)).downgradeToETH(wad); //this will transfer MATIC back to smart contract address\r\n        payable(msg.sender).transfer(wad); //this is to transfer the MATIC back to sender's account\r\n    }\r\n\r\n    function createFlow(address receiver, int96 flowRatePerMonth) external {\r\n        int96 flowRatePerSecond = (flowRatePerMonth / 3600 / 24 / 30);\r\n        i_tokenAddress.createFlow(receiver, flowRatePerSecond);\r\n    }\r\n\r\n    function updateFlow(address receiver, int96 flowRatePerMonth) external {\r\n        int96 flowRatePerSecond = (flowRatePerMonth / 3600 / 24 / 30);\r\n        i_tokenAddress.updateFlow(receiver, flowRatePerSecond);\r\n    }\r\n\r\n    function deleteFlow(address receiver) external {\r\n        i_tokenAddress.deleteFlow(address(this), receiver);\r\n    }\r\n\r\n    function withdrawfDAI(uint256 fDAIAmountOut) external {\r\n        ISuperToken(i_fDAIAddress).transfer(msg.sender, fDAIAmountOut);\r\n    }\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}