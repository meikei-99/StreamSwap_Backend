{
  "address": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "host",
          "type": "address"
        },
        {
          "internalType": "contract ISuperToken",
          "name": "tokenAddress",
          "type": "address"
        },
        {
          "internalType": "contract ISwapRouter",
          "name": "_swapRouter",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "interval",
          "type": "uint256"
        },
        {
          "internalType": "contract ISuperToken",
          "name": "fDAIAddress",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "SuperfluidStream__FlowToTheReceiverExist",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "superAmount",
          "type": "uint256"
        }
      ],
      "name": "SuperfluidStream__NotEnoughSuperToken",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "downgradeAmount",
          "type": "uint256"
        }
      ],
      "name": "DowngradeSuccess",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "int96",
          "name": "flowRatePerMonth",
          "type": "int96"
        }
      ],
      "name": "FlowCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "FlowDeleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "SwapSuccess",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "upgradeAmount",
          "type": "uint256"
        }
      ],
      "name": "UpgradeSuccess",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "POOL_FEE",
      "outputs": [
        {
          "internalType": "uint24",
          "name": "",
          "type": "uint24"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cfaLib",
      "outputs": [
        {
          "internalType": "contract ISuperfluid",
          "name": "host",
          "type": "address"
        },
        {
          "internalType": "contract IConstantFlowAgreementV1",
          "name": "cfa",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "checkUpkeep",
      "outputs": [
        {
          "internalType": "bool",
          "name": "upkeepNeeded",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "int96",
          "name": "flowRatePerMonth",
          "type": "int96"
        }
      ],
      "name": "createFlow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "deleteFlow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "wad",
          "type": "uint256"
        }
      ],
      "name": "downgradeMATICx",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "enterSwap",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDuration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getInterval",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLastTimeStamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "getMATICxBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSwapFrom",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSwapState",
      "outputs": [
        {
          "internalType": "enum SuperfluidStream.SwapState",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSwapTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSwapTo",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSwapperSwapAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "performUpkeep",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "duration",
          "type": "uint256"
        }
      ],
      "name": "swap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        },
        {
          "internalType": "int96",
          "name": "flowRatePerMonth",
          "type": "int96"
        }
      ],
      "name": "updateFlow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "upgradeMATIC",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fDAIAmountOut",
          "type": "uint256"
        }
      ],
      "name": "withdrawfDAI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x64442e511d75cb05257feb8ab69ca73215f8ed60e0c4ae641b8cecdfb689019b",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x610178dA211FEF7D417bC0e6FeD39F05609AD788",
    "transactionIndex": 0,
    "gasUsed": "2487896",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5f4e25fc066082742f7b3e89a96398e59b0357ab5ddaa644d8938b3775ac71c4",
    "transactionHash": "0x64442e511d75cb05257feb8ab69ca73215f8ed60e0c4ae641b8cecdfb689019b",
    "logs": [],
    "blockNumber": 12,
    "cumulativeGasUsed": "2487896",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x06B1D212B8da92b83AF328De5eef4E211Da02097",
    "0xd7D06eF74cC5cFd97D38Aa6080A35c509135d40A",
    "0xE592427A0AEce92De3Edee1F18E0157C05861564",
    30,
    "0xDAf76fb164DdBE358E99262331377bd81EB1e05E"
  ],
  "numDeployments": 1,
  "solcInputHash": "b160642fedcdb1ae66e5706fa0f70c28",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"contract ISuperToken\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"contract ISwapRouter\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"contract ISuperToken\",\"name\":\"fDAIAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SuperfluidStream__FlowToTheReceiverExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"superAmount\",\"type\":\"uint256\"}],\"name\":\"SuperfluidStream__NotEnoughSuperToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"downgradeAmount\",\"type\":\"uint256\"}],\"name\":\"DowngradeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int96\",\"name\":\"flowRatePerMonth\",\"type\":\"int96\"}],\"name\":\"FlowCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"FlowDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SwapSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upgradeAmount\",\"type\":\"uint256\"}],\"name\":\"UpgradeSuccess\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"POOL_FEE\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cfaLib\",\"outputs\":[{\"internalType\":\"contract ISuperfluid\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"contract IConstantFlowAgreementV1\",\"name\":\"cfa\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"flowRatePerMonth\",\"type\":\"int96\"}],\"name\":\"createFlow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deleteFlow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"downgradeMATICx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"getMATICxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFrom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapState\",\"outputs\":[{\"internalType\":\"enum SuperfluidStream.SwapState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapperSwapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"int96\",\"name\":\"flowRatePerMonth\",\"type\":\"int96\"}],\"name\":\"updateFlow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeMATIC\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fDAIAmountOut\",\"type\":\"uint256\"}],\"name\":\"withdrawfDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SuperfluidStream.sol\":\"SuperfluidStream\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/AutomationBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract AutomationBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    if (tx.origin != address(0)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x5d354afa1a97dffe66094397cdcbb0c14713cf3d609d88fd8f9891010e9a351a\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AutomationBase.sol\\\";\\nimport \\\"./interfaces/AutomationCompatibleInterface.sol\\\";\\n\\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\\n\",\"keccak256\":\"0x40e5ae0eff4edd0740c1b5590d09c344f84dee031e82d5294563e99603774f80\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\",\"keccak256\":\"0x67076747c6f66d8d43472a56e72879c350056bff82e069addaf9064922863340\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x190dd6f8d592b7e4e930feb7f4313aeb8e1c4ad3154c27ce1cf6a512fc30d8cc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\\n     *\\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\\n     */\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    /**\\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\\n     */\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\\n     */\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n}\\n\",\"keccak256\":\"0x385a7061f1436b079d44c140dee9387d5313e94874ff9ee877dc0085c981ac3d\",\"license\":\"MIT\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperfluidToken\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nimport {\\n    IConstantFlowAgreementV1\\n} from \\\"../interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\n\\n/**\\n * @title Constant flow agreement v1 library\\n * @author Superfluid\\n * @dev for working with the constant flow agreement within solidity\\n * @dev the first set of functions are each for callAgreement()\\n * @dev the second set of functions are each for use in callAgreementWithContext()\\n */\\nlibrary CFAv1Library {\\n\\n    /**\\n     * @dev Initialization data\\n     * @param host Superfluid host for calling agreements\\n     * @param cfa Constant Flow Agreement contract\\n     */\\n    struct InitData {\\n        ISuperfluid host;\\n        IConstantFlowAgreementV1 cfa;\\n    }\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        createFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal {\\n        updateFlow(cfaLibrary, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlow(\\n        InitData storage cfaLibrary,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal {\\n        deleteFlow(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlow(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal {\\n        cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowWithCtx(cfaLibrary, ctx, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Update flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Delete flow with context and userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return createFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperator(cfaLibrary, sender, receiver, token, flowRate, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate\\n    ) internal returns (bytes memory newCtx) {\\n        return updateFlowByOperatorWithCtx(\\n            cfaLibrary,\\n            ctx,\\n            sender,\\n            receiver,\\n            token,\\n            flowRate,\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperator(cfaLibrary, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperator(\\n        InitData storage cfaLibrary,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator without userData with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return deleteFlowByOperatorWithCtx(cfaLibrary, ctx, sender, receiver, token, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Deletes a flow as an operator with userData and context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param token The token to flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowByOperatorWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address sender,\\n        address receiver,\\n        ISuperfluidToken token,\\n        bytes memory userData\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0)\\n                )\\n            ),\\n            userData,\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissions(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the permissions of a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     * @param permissions The number of the permissions: create = 1; update = 2; delete = 4;\\n     * To give multiple permissions, sum the above. create_delete = 5; create_update_delete = 7; etc\\n     * @param flowRateAllowance The allowance for flow creation. Decremented as flowRate increases\\n     */\\n    function updateFlowOperatorPermissionsWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissions,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Grants full, unlimited permission to a flow operator with context\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function authorizeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        InitData storage cfaLibrary,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        return cfaLibrary.host.callAgreement(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0)\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes all permissions from a flow operator\\n     * @param cfaLibrary The cfaLibrary storage variable\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param flowOperator The operator that can create/update/delete flows\\n     * @param token The token of flows handled by the operator\\n     */\\n    function revokeFlowOperatorWithFullControlWithCtx(\\n        InitData storage cfaLibrary,\\n        bytes memory ctx,\\n        address flowOperator,\\n        ISuperfluidToken token\\n    ) internal returns (bytes memory newCtx) {\\n        (newCtx, ) = cfaLibrary.host.callAgreementWithContext(\\n            cfaLibrary.cfa,\\n            abi.encodeCall(\\n                cfaLibrary.cfa.revokeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            new bytes(0),\\n            ctx\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x5384b9a56711ce7b72405c653ff8be3bb94131428919b380248e10f1ddb252de\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.0;\\n\\nimport {\\n    ISuperfluid,\\n    ISuperToken\\n} from \\\"../interfaces/superfluid/ISuperfluid.sol\\\";\\n\\nimport {\\n    IConstantFlowAgreementV1\\n} from \\\"../interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\n\\nimport {\\n    IInstantDistributionAgreementV1\\n} from \\\"../interfaces/agreements/IInstantDistributionAgreementV1.sol\\\";\\n\\n/**\\n * @title Library for Token Centric Interface\\n * @author Superfluid\\n * @dev Set `using for ISuperToken` in including file, and call any of these functions on an instance\\n * of ISuperToken\\n */\\nlibrary SuperTokenV1Library {\\n\\n    /** CFA BASE CRUD ************************************* */\\n\\n    /**\\n     * @dev Create flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0) // userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Create flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function createFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow without userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0) // userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Update flow with userData\\n     * @param token The token used in flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The userdata passed along with call\\n     */\\n    function updateFlow(ISuperToken token, address receiver, int96 flowRate, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (token, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow without userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            new bytes(0) // userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Delete flow with userData\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The userdata passed along with call\\n     */\\n    function deleteFlow(ISuperToken token, address sender, address receiver, bytes memory userData)\\n        internal returns (bool)\\n    {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** CFA ACL ************************************* */\\n\\n    /**\\n     * @dev Update permissions for flow operator\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     */\\n    function setFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (token, flowOperator, permissionsBitmask, flowRateAllowance, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function setMaxFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     */\\n    function revokeFlowPermissions(\\n        ISuperToken token,\\n        address flowOperator\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator in callback\\n     * @notice allowing userData to be a parameter here triggered stack to deep error\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param allowCreate creation permissions\\n     * @param allowCreate update permissions\\n     * @param allowCreate deletion permissions\\n     * @param flowRateAllowance The allowance provided to flowOperator\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bool allowCreate,\\n        bool allowUpdate,\\n        bool allowDelete,\\n        int96 flowRateAllowance,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        uint8 permissionsBitmask = (allowCreate ? 1 : 0)\\n            | (allowUpdate ? 1 : 0) << 1\\n            | (allowDelete ? 1 : 0) << 2;\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowOperatorPermissions,\\n                (\\n                    token,\\n                    flowOperator,\\n                    permissionsBitmask,\\n                    flowRateAllowance,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update permissions for flow operator - give operator max permissions\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function setMaxFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.authorizeFlowOperatorWithFullControl,\\n                (\\n                    token,\\n                    flowOperator,\\n                    new bytes(0)\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n    * @dev Update permissions for flow operator - revoke all permission\\n     * @param token The token used in flow\\n     * @param flowOperator The address given flow permissions\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowPermissionsWithCtx(\\n        ISuperToken token,\\n        address flowOperator,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.revokeFlowOperatorWithFullControl,\\n                (token, flowOperator, new bytes(0))\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n\\n    /**\\n     * @dev Creates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function createFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Updates flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param userData The user provided data\\n     */\\n    function updateFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (token, sender, receiver, flowRate, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n     /**\\n     * @dev Deletes flow as an operator without userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            new bytes(0)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes flow as an operator with userData\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param userData The user provided data\\n     */\\n    function deleteFlowFrom(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        host.callAgreement(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (token, sender, receiver, new bytes(0))\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n\\n    /** CFA With CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Create flow with context and userData\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Create flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function createFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.createFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow with context\\n     * @param token The token to flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowWithCtx(\\n        ISuperToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlow,\\n                (\\n                    token,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Update flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The receiver of the flow\\n     * @param receiver The receiver of the flow\\n     * @param flowRate The desired flowRate\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.updateFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    flowRate,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlow,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Delete flow by operator with context\\n     * @param token The token to flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function deleteFlowFromWithCtx(\\n        ISuperToken token,\\n        address sender,\\n        address receiver,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IConstantFlowAgreementV1 cfa) = _getAndCacheHostAndCFA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            cfa,\\n            abi.encodeCall(\\n                cfa.deleteFlowByOperator,\\n                (\\n                    token,\\n                    sender,\\n                    receiver,\\n                    new bytes(0) // placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /** CFA VIEW FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev get flow rate between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return flowRate The flow rate\\n     */\\n    function getFlowRate(ISuperToken token, address sender, address receiver)\\n        internal view returns(int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (, flowRate, , ) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get flow info between two accounts for given token\\n     * @param token The token used in flow\\n     * @param sender The sender of the flow\\n     * @param receiver The receiver of the flow\\n     * @return lastUpdated Timestamp of flow creation or last flowrate change\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlowInfo(ISuperToken token, address sender, address receiver)\\n        internal view\\n        returns(uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        (lastUpdated, flowRate, deposit, owedDeposit) = cfa.getFlow(token, sender, receiver);\\n    }\\n\\n    /**\\n     * @dev get net flow rate for given account for given token\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return flowRate The net flow rate of the account\\n     */\\n    function getNetFlowRate(ISuperToken token, address account)\\n        internal view returns (int96 flowRate)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getNetFlow(token, account);\\n    }\\n\\n    /**\\n     * @dev get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account to query\\n     * @return lastUpdated Timestamp of the last change of the net flow\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getNetFlowInfo(ISuperToken token, address account)\\n        internal view\\n        returns (uint256 lastUpdated, int96 flowRate, uint256 deposit, uint256 owedDeposit)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getAccountFlowInfo(token, account);\\n    }\\n\\n    /**\\n     * @dev calculate buffer for a flow rate\\n     * @param token The token used in flow\\n     * @param flowRate The flowrate to calculate the needed buffer for\\n     * @return bufferAmount The buffer amount based on flowRate, liquidationPeriod and minimum deposit\\n     */\\n    function getBufferAmountByFlowRate(ISuperToken token, int96 flowRate) internal view\\n        returns (uint256 bufferAmount)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        return cfa.getDepositRequiredForFlowRate(token, flowRate);\\n    }\\n\\n    /**\\n     * @dev get existing flow permissions\\n     * @param token The token used in flow\\n     * @param sender sender of a flow\\n     * @param flowOperator the address we are checking permissions of for sender & token\\n     * @return allowCreate is true if the flowOperator can create flows\\n     * @return allowUpdate is true if the flowOperator can update flows\\n     * @return allowDelete is true if the flowOperator can delete flows\\n     * @return flowRateAllowance The flow rate allowance the flowOperator is granted (only goes down)\\n     */\\n    function getFlowPermissions(ISuperToken token, address sender, address flowOperator)\\n        internal view\\n        returns (bool allowCreate, bool allowUpdate, bool allowDelete, int96 flowRateAllowance)\\n    {\\n        (, IConstantFlowAgreementV1 cfa) = _getHostAndCFA(token);\\n        uint8 permissionsBitmask;\\n        (, permissionsBitmask, flowRateAllowance) = cfa.getFlowOperatorData(token, sender, flowOperator);\\n        allowCreate = permissionsBitmask & 1 == 1 ? true : false;\\n        allowUpdate = permissionsBitmask >> 1 & 1 == 1 ? true : false;\\n        allowDelete = permissionsBitmask >> 2 & 1 == 1 ? true : false;\\n    }\\n\\n\\n     /** IDA VIEW FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Gets an index by its ID and publisher.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @return exist True if the index exists.\\n     * @return indexValue Total value of the index.\\n     * @return totalUnitsApproved Units of the index approved by subscribers.\\n     * @return totalUnitsPending Units of teh index not yet approved by subscribers.\\n     */\\n    function getIndex(ISuperToken token, address publisher, uint32 indexId)\\n        internal view\\n        returns (bool exist, uint128 indexValue, uint128 totalUnitsApproved, uint128 totalUnitsPending)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getIndex(token, publisher, indexId);\\n    }\\n\\n    /**\\n     * @dev Calculates the distribution amount based on the amount of tokens desired to distribute.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount of tokens desired to distribute.\\n     * @return actualAmount Amount to be distributed with correct rounding.\\n     * @return newIndexValue The index value after the distribution would be called.\\n     */\\n    function calculateDistribution(ISuperToken token, address publisher, uint32 indexId, uint256 amount)\\n        internal view\\n        returns (uint256 actualAmount, uint128 newIndexValue)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.calculateDistribution(token, publisher, indexId, amount);\\n    }\\n\\n    /**\\n     * @dev List all subscriptions of an address\\n     * @param token Super token used in the indexes listed.\\n     * @param subscriber Subscriber address.\\n     * @return publishers Publishers of the indices.\\n     * @return indexIds IDs of the indices.\\n     * @return unitsList Units owned of the indices.\\n     */\\n    function listSubscriptions(\\n        ISuperToken token,\\n        address subscriber\\n    )\\n        internal view\\n        returns (\\n            address[] memory publishers,\\n            uint32[] memory indexIds,\\n            uint128[] memory unitsList\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.listSubscriptions(token, subscriber);\\n    }\\n\\n    /**\\n     * @dev Gets subscription by publisher, index id, and subscriber.\\n     * @param token Super token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber to the index.\\n     * @return exist True if the subscription exists.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscription(ISuperToken token, address publisher, uint32 indexId, address subscriber)\\n        internal view\\n        returns (bool exist, bool approved, uint128 units, uint256 pendingDistribution)\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscription(token, publisher, indexId, subscriber);\\n    }\\n\\n    /*\\n     * @dev Gets subscription by the agreement ID.\\n     * @param token Super Token used with the index.\\n     * @param agreementId Agreement ID, unique to the subscriber and index ID.\\n     * @return publisher Publisher of the index.\\n     * @return indexId ID of the index.\\n     * @return approved True if the subscription has been approved by the subscriber.\\n     * @return units Units held by the subscriber\\n     * @return pendingDistribution If not approved, the amount to be claimed on approval.\\n     */\\n    function getSubscriptionByID(ISuperToken token, bytes32 agreementId)\\n        internal view\\n        returns (\\n            address publisher,\\n            uint32 indexId,\\n            bool approved,\\n            uint128 units,\\n            uint256 pendingDistribution\\n        )\\n    {\\n        (, IInstantDistributionAgreementV1 ida) = _getHostAndIDA(token);\\n        return ida.getSubscriptionByID(token, agreementId);\\n    }\\n\\n\\n    /** IDA BASE FUNCTIONS ************************************* */\\n\\n\\n    /**\\n     * @dev Creates a new index.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates a new index with userData.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function createIndex(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates an index value with userData. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateIndexValue(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex` (w user data). Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function distribute(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index with user data. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function approveSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function revokeSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber holds\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function updateSubscriptionUnits(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary userdata.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function deleteSubscription(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\"\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary user data.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param userData Arbitrary user data field.\\n     */\\n    function claim(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory userData\\n    ) internal returns (bool) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        host.callAgreement(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            userData\\n        );\\n        return true;\\n    }\\n\\n    /** IDA WITH CTX FUNCTIONS ************************************* */\\n\\n    /**\\n     * @dev Creates a new index with ctx.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function createIndexWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.createIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates an index value with ctx. This distributes an amount of tokens equal to\\n     * `indexValue - lastIndexValue`. See `distribute` for another way to distribute.\\n     * Meant for usage in super app callbakcs\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param indexValue New TOTAL index value, this will equal the total amount distributed.\\n     * @param ctx from super app callback\\n     */\\n    function updateIndexValueWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.updateIndex,\\n                (\\n                    token,\\n                    indexId,\\n                    indexValue,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Distributes tokens in a more developer friendly way than `updateIndex`.Instead of\\n     * passing the new total index value, this function will increase the index value by `amount`.\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param amount Amount by which the index value should increase.\\n     * @param ctx from super app callback\\n     */\\n    function distributeWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.distribute,\\n                (\\n                    token,\\n                    indexId,\\n                    amount,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Approves a subscription to an index. The subscriber's real time balance will not update\\n     * until the subscription is approved, but once approved, the balance will be updated with\\n     * prior distributions.\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function approveSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.approveSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Revokes a previously approved subscription. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param ctx from super app callback\\n     */\\n    function revokeSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.revokeSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Updates the units of a subscription. This changes the number of shares the subscriber\\n     * holds. Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be updated.\\n     * @param units New number of units the subscriber holds.\\n     * @param ctx from super app callback\\n     */\\n    function updateSubscriptionUnitsWithCtx(\\n        ISuperToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n         ida,\\n            abi.encodeCall(\\n                ida.updateSubscription,\\n                (\\n                    token,\\n                    indexId,\\n                    subscriber,\\n                    units,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Deletes a subscription, setting a subcriber's units to zero.\\n     * Meant for usage in super apps\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address whose units are to be deleted.\\n     * @param ctx from super app callback\\n     */\\n    function deleteSubscriptionWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n        (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.deleteSubscription,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    /**\\n     * @dev Claims pending distribution. Subscription should not be approved.\\n     * Meant for usage in super app callbacks\\n     * @param token Super Token used with the index.\\n     * @param publisher Publisher of the index.\\n     * @param indexId ID of the index.\\n     * @param subscriber Subscriber address that receives the claim.\\n     * @param ctx from super app callback\\n     */\\n    function claimWithCtx(\\n        ISuperToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes memory ctx\\n    ) internal returns (bytes memory newCtx) {\\n         (ISuperfluid host, IInstantDistributionAgreementV1 ida) = _getAndCacheHostAndIDA(token);\\n        (newCtx, ) = host.callAgreementWithContext(\\n            ida,\\n            abi.encodeCall(\\n                ida.claim,\\n                (\\n                    token,\\n                    publisher,\\n                    indexId,\\n                    subscriber,\\n                    new bytes(0) // ctx placeholder\\n                )\\n            ),\\n            \\\"0x\\\",\\n            ctx\\n        );\\n    }\\n\\n    // ************** private helpers **************\\n\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.host\\\")\\n    bytes32 private constant _HOST_SLOT = 0x65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea837;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.cfa\\\")\\n    bytes32 private constant _CFA_SLOT = 0xb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a;\\n    // keccak256(\\\"org.superfluid-finance.apps.SuperTokenLibrary.v1.ida\\\");\\n    bytes32 private constant _IDA_SLOT = 0xa832ee1924ea960211af2df07d65d166232018f613ac6708043cd8f8773eddeb;\\n\\n    // gets the host and cfa addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndCFA(ISuperToken token) private\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                //keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\")\\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_CFA_SLOT, cfa)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token and caches it in storage for gas efficiency\\n    // to be used in state changing methods\\n    function _getAndCacheHostAndIDA(ISuperToken token) private\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                    keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\"))));\\n            // now that we got them and are in a transaction context, persist in storage\\n            assembly {\\n            // solium-disable-line\\n                sstore(_HOST_SLOT, host)\\n                sstore(_IDA_SLOT, ida)\\n            }\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n\\n    // gets the host and cfa addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndCFA(ISuperToken token) private view\\n        returns(ISuperfluid host, IConstantFlowAgreementV1 cfa)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            cfa := sload(_CFA_SLOT)\\n        }\\n        if (address(cfa) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            cfa = IConstantFlowAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                //keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\")\\n                    0xa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd3)));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(cfa) != address(0));\\n    }\\n\\n    // gets the host and ida addrs for the token\\n    // to be used in non-state changing methods (view functions)\\n    function _getHostAndIDA(ISuperToken token) private view\\n        returns(ISuperfluid host, IInstantDistributionAgreementV1 ida)\\n    {\\n        // check if already in contract storage...\\n        assembly { // solium-disable-line\\n            host := sload(_HOST_SLOT)\\n            ida := sload(_IDA_SLOT)\\n        }\\n        if (address(ida) == address(0)) {\\n            // framework contract addrs not yet cached in storage, retrieving now...\\n            if (address(host) == address(0)) {\\n                host = ISuperfluid(token.getHost());\\n            }\\n            ida = IInstantDistributionAgreementV1(address(ISuperfluid(host).getAgreementClass(\\n                //keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\")\\n                    0x15609310ae3c30189a1218b7adabaf36c267255e70cf91b6cba384367d9eda32)));\\n        }\\n        assert(address(host) != address(0));\\n        assert(address(ida) != address(0));\\n    }\\n}\\n\",\"keccak256\":\"0x1b588d76f3addfeb2f368ec534fbd8da6120c8ba3c08e95f410a9cc2204faf79\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Constant Flow Agreement interface\\n * @author Superfluid\\n */\\nabstract contract IConstantFlowAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error CFA_ACL_NO_SENDER_CREATE();               // 0x4b993136\\n    error CFA_ACL_NO_SENDER_UPDATE();               // 0xedfa0d3b\\n    error CFA_ACL_OPERATOR_NO_CREATE_PERMISSIONS(); // 0xa3eab6ac\\n    error CFA_ACL_OPERATOR_NO_UPDATE_PERMISSIONS(); // 0xac434b5f\\n    error CFA_ACL_OPERATOR_NO_DELETE_PERMISSIONS(); // 0xe30f1bff\\n    error CFA_ACL_FLOW_RATE_ALLOWANCE_EXCEEDED();   // 0xa0645c1f\\n    error CFA_ACL_UNCLEAN_PERMISSIONS();            // 0x7939d66c\\n    error CFA_ACL_NO_SENDER_FLOW_OPERATOR();        // 0xb0ed394d\\n    error CFA_ACL_NO_NEGATIVE_ALLOWANCE();          // 0x86e0377d\\n    error CFA_FLOW_ALREADY_EXISTS();                // 0x801b6863\\n    error CFA_FLOW_DOES_NOT_EXIST();                // 0x5a32bf24\\n    error CFA_INSUFFICIENT_BALANCE();               // 0xea76c9b3\\n    error CFA_ZERO_ADDRESS_SENDER();                // 0x1ce9b067\\n    error CFA_ZERO_ADDRESS_RECEIVER();              // 0x78e02b2a\\n    error CFA_HOOK_OUT_OF_GAS();                    // 0x9f76430b\\n    error CFA_DEPOSIT_TOO_BIG();                    // 0x752c2b9c\\n    error CFA_FLOW_RATE_TOO_BIG();                  // 0x0c9c55c1\\n    error CFA_NON_CRITICAL_SENDER();                // 0xce11b5d1\\n    error CFA_INVALID_FLOW_RATE();                  // 0x91acad16\\n    error CFA_NO_SELF_FLOW();                       // 0xa47338ef\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\");\\n    }\\n\\n    /**\\n     * @notice Get the maximum flow rate allowed with the deposit\\n     * @dev The deposit is clipped and rounded down\\n     * @param deposit Deposit amount used for creating the flow\\n     * @return flowRate The maximum flow rate\\n     */\\n    function getMaximumFlowRateFromDeposit(\\n        ISuperfluidToken token,\\n        uint256 deposit)\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Get the deposit required for creating the flow\\n     * @dev Calculates the deposit based on the liquidationPeriod and flowRate\\n     * @param flowRate Flow rate to be tested\\n     * @return deposit The deposit amount based on flowRate and liquidationPeriod\\n     * @custom:note \\n     * - if calculated deposit (flowRate * liquidationPeriod) is less\\n     *   than the minimum deposit, we use the minimum deposit otherwise\\n     *   we use the calculated deposit\\n     */\\n    function getDepositRequiredForFlowRate(\\n        ISuperfluidToken token,\\n        int96 flowRate)\\n        external view virtual\\n        returns (uint256 deposit);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on host.getNow()\\n     * @param account The account we are interested in\\n     * @return isCurrentlyPatricianPeriod Whether it is currently the patrician period dictated by governance\\n     * @return timestamp The value of host.getNow()\\n     */\\n    function isPatricianPeriodNow(\\n        ISuperfluidToken token,\\n        address account)\\n        external view virtual\\n        returns (bool isCurrentlyPatricianPeriod, uint256 timestamp);\\n\\n    /**\\n     * @dev Returns whether it is the patrician period based on timestamp\\n     * @param account The account we are interested in\\n     * @param timestamp The timestamp we are interested in observing the result of isPatricianPeriod\\n     * @return bool Whether it is currently the patrician period dictated by governance\\n     */\\n    function isPatricianPeriod(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 timestamp\\n    )\\n        public view virtual\\n        returns (bool);\\n\\n    /**\\n     * @dev msgSender from `ctx` updates permissions for the `flowOperator` with `flowRateAllowance`\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param permissions A bitmask representation of the granted permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function updateFlowOperatorPermissions(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance,\\n        bytes calldata ctx\\n    ) \\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev msgSender from `ctx` grants `flowOperator` all permissions with flowRateAllowance as type(int96).max\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function authorizeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n     /**\\n     * @notice msgSender from `ctx` revokes `flowOperator` create/update/delete permissions\\n     * @dev `permissions` and `flowRateAllowance` will both be set to 0\\n     * @param token Super token address\\n     * @param flowOperator The permission grantee address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     */\\n    function revokeFlowOperatorWithFullControl(\\n        ISuperfluidToken token,\\n        address flowOperator,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Get the permissions of a flow operator between `sender` and `flowOperator` for `token`\\n     * @param token Super token address\\n     * @param sender The permission granter address\\n     * @param flowOperator The permission grantee address\\n     * @return flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorData(\\n       ISuperfluidToken token,\\n       address sender,\\n       address flowOperator\\n    )\\n        public view virtual\\n        returns (\\n            bytes32 flowOperatorId,\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Get flow operator using flowOperatorId\\n     * @param token Super token address\\n     * @param flowOperatorId The keccak256 hash of encoded string \\\"flowOperator\\\", sender and flowOperator\\n     * @return permissions A bitmask representation of the granted permissions\\n     * @return flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    function getFlowOperatorDataByID(\\n       ISuperfluidToken token,\\n       bytes32 flowOperatorId\\n    )\\n        external view virtual\\n        returns (\\n            uint8 permissions,\\n            int96 flowRateAllowance\\n        );\\n\\n    /**\\n     * @notice Create a flow betwen ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - AgreementCreated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - A deposit is taken as safety margin for the solvency agents\\n     * - A extra gas fee may be taken to pay for solvency agent liquidations\\n     */\\n    function createFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Create a flow between sender and receiver\\n    * @dev A flow created by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function createFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Update the flow rate between ctx.msgSender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param receiver Flow receiver address\\n     * @param flowRate New flow rate in amount per second\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - AgreementUpdated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - Only the flow sender may update the flow rate\\n     * - Even if the flow rate is zero, the flow is not deleted\\n     * from the system\\n     * - Deposit amount will be adjusted accordingly\\n     * - No new gas fee is charged\\n     */\\n    function updateFlow(\\n        ISuperfluidToken token,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n    * @notice Update a flow between sender and receiver\\n    * @dev A flow updated by an approved flow operator (see above for details on callbacks)\\n    * @param token Super token address\\n    * @param sender Flow sender address (has granted permissions)\\n    * @param receiver Flow receiver address\\n    * @param flowRate New flow rate in amount per second\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    */\\n    function updateFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        int96 flowRate,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev Get the flow data between `sender` and `receiver` of `token`\\n     * @param token Super token address\\n     * @param sender Flow receiver\\n     * @param receiver Flow sender\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The amount of deposit the flow\\n     * @return owedDeposit The amount of owed deposit of the flow\\n     */\\n    function getFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @notice Get flow data using agreementId\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return timestamp Timestamp of when the flow is updated\\n     * @return flowRate The flow rate\\n     * @return deposit The deposit amount of the flow\\n     * @return owedDeposit The owed deposit amount of the flow\\n     */\\n    function getFlowByID(\\n       ISuperfluidToken token,\\n       bytes32 agreementId\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n    /**\\n     * @dev Get the aggregated flow info of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return timestamp Timestamp of when a flow was last updated for account\\n     * @return flowRate The net flow rate of token for account\\n     * @return deposit The sum of all deposits for account's flows\\n     * @return owedDeposit The sum of all owed deposits for account's flows\\n     */\\n    function getAccountFlowInfo(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (\\n            uint256 timestamp,\\n            int96 flowRate,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @dev Get the net flow rate of the account\\n     * @param token Super token address\\n     * @param account Account for the query\\n     * @return flowRate Net flow rate\\n     */\\n    function getNetFlow(\\n        ISuperfluidToken token,\\n        address account\\n    )\\n        external view virtual\\n        returns (int96 flowRate);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev flowId (agreementId) is the keccak256 hash of encoded sender and receiver\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     *\\n     * @custom:callbacks \\n     * - AgreementTerminated\\n     *   - agreementId - can be used in getFlowByID\\n     *   - agreementData - abi.encode(address flowSender, address flowReceiver)\\n     *\\n     * @custom:note \\n     * - Both flow sender and receiver may delete the flow\\n     * - If Sender account is insolvent or in critical state, a solvency agent may\\n     *   also terminate the agreement\\n     * - Gas fee may be returned to the sender\\n     */\\n    function deleteFlow(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @notice Delete the flow between sender and receiver\\n     * @dev A flow deleted by an approved flow operator (see above for details on callbacks)\\n     * @param token Super token address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     * @param receiver Flow receiver address\\n     */\\n    function deleteFlowByOperator(\\n        ISuperfluidToken token,\\n        address sender,\\n        address receiver,\\n        bytes calldata ctx\\n    )\\n        external virtual\\n        returns(bytes memory newCtx);\\n     \\n    /**\\n     * @dev Flow operator updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param flowOperator Flow operator address\\n     * @param permissions Octo bitmask representation of permissions\\n     * @param flowRateAllowance The flow rate allowance the `flowOperator` is granted (only goes down)\\n     */\\n    event FlowOperatorUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed flowOperator,\\n        uint8 permissions,\\n        int96 flowRateAllowance\\n    );\\n\\n    /**\\n     * @dev Flow updated event\\n     * @param token Super token address\\n     * @param sender Flow sender address\\n     * @param receiver Flow recipient address\\n     * @param flowRate Flow rate in amount per second for this flow\\n     * @param totalSenderFlowRate Total flow rate in amount per second for the sender\\n     * @param totalReceiverFlowRate Total flow rate in amount per second for the receiver\\n     * @param userData The user provided data\\n     *\\n     */\\n    event FlowUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed sender,\\n        address indexed receiver,\\n        int96 flowRate,\\n        int256 totalSenderFlowRate,\\n        int256 totalReceiverFlowRate,\\n        bytes userData\\n    );\\n\\n    /**\\n     * @dev Flow updated extension event\\n     * @param flowOperator Flow operator address - the Context.msgSender\\n     * @param deposit The deposit amount for the stream\\n     */\\n    event FlowUpdatedExtension(\\n        address indexed flowOperator,\\n        uint256 deposit\\n    );\\n}\\n\",\"keccak256\":\"0xce0197c49f5bb56f1446398e20347aedb1f490b243db064ac35a9ace25a96139\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IInstantDistributionAgreementV1.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"../superfluid/ISuperAgreement.sol\\\";\\nimport { ISuperfluidToken } from \\\"../superfluid/ISuperfluidToken.sol\\\";\\n\\n\\n/**\\n * @title Instant Distribution Agreement interface\\n * @author Superfluid\\n *\\n * @notice \\n *   - A publisher can create as many as indices as possibly identifiable with `indexId`.\\n *     - `indexId` is deliberately limited to 32 bits, to avoid the chance for sha-3 collision.\\n *       Despite knowing sha-3 collision is only theoretical.\\n *   - A publisher can create a subscription to an index for any subscriber.\\n *   - A subscription consists of:\\n *     - The index it subscribes to.\\n *     - Number of units subscribed.\\n *   - An index consists of:\\n *     - Current value as `uint128 indexValue`.\\n *     - Total units of the approved subscriptions as `uint128 totalUnitsApproved`.\\n *     - Total units of the non approved subscription as `uint128 totalUnitsPending`.\\n *   - A publisher can update an index with a new value that doesn't decrease.\\n *   - A publisher can update a subscription with any number of units.\\n *   - A publisher or a subscriber can delete a subscription and reset its units to zero.\\n *   - A subscriber must approve the index in order to receive distributions from the publisher\\n *     each time the index is updated.\\n *     - The amount distributed is $$\\\\Delta{index} * units$$\\n *   - Distributions to a non approved subscription stays in the publisher's deposit until:\\n *     - the subscriber approves the subscription (side effect),\\n *     - the publisher updates the subscription (side effect),\\n *     - the subscriber deletes the subscription even if it is never approved (side effect),\\n *     - or the subscriber can explicitly claim them.\\n */\\nabstract contract IInstantDistributionAgreementV1 is ISuperAgreement {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error IDA_INDEX_SHOULD_GROW();             // 0xcfdca725\\n    error IDA_OPERATION_NOT_ALLOWED();         // 0x92da6d17\\n    error IDA_INDEX_ALREADY_EXISTS();          // 0x5c02a517\\n    error IDA_INDEX_DOES_NOT_EXIST();          // 0xedeaa63b\\n    error IDA_SUBSCRIPTION_DOES_NOT_EXIST();   // 0xb6c8c980\\n    error IDA_SUBSCRIPTION_ALREADY_APPROVED(); // 0x3eb2f849\\n    error IDA_SUBSCRIPTION_IS_NOT_APPROVED();  // 0x37412573\\n    error IDA_INSUFFICIENT_BALANCE();          // 0x16e759bb\\n    error IDA_ZERO_ADDRESS_SUBSCRIBER();       // 0xc90a4674\\n\\n    /// @dev ISuperAgreement.agreementType implementation\\n    function agreementType() external override pure returns (bytes32) {\\n        return keccak256(\\\"org.superfluid-finance.agreements.InstantDistributionAgreement.v1\\\");\\n    }\\n\\n    /**************************************************************************\\n     * Index operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Create a new index for the publisher\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function createIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n    * @dev Index created event\\n    * @param token Super token address\\n    * @param publisher Index creator and publisher\\n    * @param indexId The specified indexId of the newly created index\\n    * @param userData The user provided data\\n    */\\n    event IndexCreated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Query the data of a index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @return exist Does the index exist\\n     * @return indexValue Value of the current index\\n     * @return totalUnitsApproved Total units approved for the index\\n     * @return totalUnitsPending Total units pending approval for the index\\n     */\\n    function getIndex(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                uint128 indexValue,\\n                uint128 totalUnitsApproved,\\n                uint128 totalUnitsPending);\\n\\n    /**\\n     * @dev Calculate actual distribution amount\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @return actualAmount The amount to be distributed after ensuring no rounding errors\\n     * @return newIndexValue The index value given the desired amount of tokens to be distributed\\n     */\\n    function calculateDistribution(\\n       ISuperfluidToken token,\\n       address publisher,\\n       uint32 indexId,\\n       uint256 amount)\\n           external view\\n           virtual\\n           returns(\\n               uint256 actualAmount,\\n               uint128 newIndexValue);\\n\\n    /**\\n     * @dev Update index value of an index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param indexValue Value of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function updateIndex(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint128 indexValue,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index updated event\\n      * @param token Super token address\\n      * @param publisher Index updater and publisher\\n      * @param indexId The specified indexId of the updated index\\n      * @param oldIndexValue The previous index value\\n      * @param newIndexValue The updated index value\\n      * @param totalUnitsPending The total units pending when the indexValue was updated\\n      * @param totalUnitsApproved The total units approved when the indexValue was updated\\n      * @param userData The user provided data\\n      */\\n    event IndexUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        uint128 oldIndexValue,\\n        uint128 newIndexValue,\\n        uint128 totalUnitsPending,\\n        uint128 totalUnitsApproved,\\n        bytes userData);\\n\\n    /**\\n     * @dev Distribute tokens through the index\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param amount The amount of tokens desired to be distributed\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:note \\n     * - This is a convenient version of updateIndex. It adds to the index\\n     *   a delta that equals to `amount / totalUnits`\\n     * - The actual amount distributed could be obtained via\\n     *   `calculateDistribution`. This is due to precision error with index\\n     *   value and units data range\\n     *\\n     * @custom:callbacks \\n     * None\\n     */\\n    function distribute(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        uint256 amount,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n\\n    /**************************************************************************\\n     * Subscription operations\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Approve the subscription of an index\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the publisher:\\n     *      - agreementId is for the subscription\\n     */\\n    function approveSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n    /**\\n      * @dev Index subscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The approved subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexSubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n\\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionApproved(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n    * @notice Revoke the subscription of an index\\n    * @dev \\\"Unapproves\\\" the subscription and moves approved units to pending\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function revokeSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        bytes calldata ctx)\\n         external\\n         virtual\\n         returns(bytes memory newCtx);\\n    /**\\n      * @dev Index unsubscribed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The unsubscribed subscriber\\n      * @param userData The user provided data\\n      */\\n    event IndexUnsubscribed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription approved event\\n      * @param token Super token address\\n      * @param subscriber The approved subscriber\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionRevoked(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        bytes userData);\\n\\n    /**\\n     * @dev Update the nuber of units of a subscription\\n     * @param token Super token address\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @param units Number of units of the subscription\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if subscription exist\\n     *   - AgreementCreated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     * - if subscription does not exist\\n     *   - AgreementUpdated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function updateSubscription(\\n        ISuperfluidToken token,\\n        uint32 indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n      * @dev Index units updated event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event IndexUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint128 units,\\n        bytes userData);\\n    \\n    /**\\n      * @dev Subscription units updated event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param indexId The specified indexId\\n      * @param publisher Index publisher\\n      * @param units The new units amount\\n      * @param userData The user provided data\\n      */\\n    event SubscriptionUnitsUpdated(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint128 units,\\n        bytes userData);\\n\\n    /**\\n     * @dev Get data of a subscription\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber of the index\\n     * @return exist Does the subscription exist?\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                bool exist,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @notice Get data of a subscription by agreement ID\\n     * @dev indexId (agreementId) is the keccak256 hash of encodePacked(\\\"publisher\\\", publisher, indexId)\\n     * @param token Super token address\\n     * @param agreementId The agreement ID\\n     * @return publisher The publisher of the index\\n     * @return indexId Id of the index\\n     * @return approved Is the subscription approved?\\n     * @return units Units of the suscription\\n     * @return pendingDistribution Pending amount of tokens to be distributed for unapproved subscription\\n     */\\n    function getSubscriptionByID(\\n        ISuperfluidToken token,\\n        bytes32 agreementId)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address publisher,\\n                uint32 indexId,\\n                bool approved,\\n                uint128 units,\\n                uint256 pendingDistribution\\n            );\\n\\n    /**\\n     * @dev List subscriptions of an user\\n     * @param token Super token address\\n     * @param subscriber The subscriber's address\\n     * @return publishers Publishers of the subcriptions\\n     * @return indexIds Indexes of the subscriptions\\n     * @return unitsList Units of the subscriptions\\n     */\\n    function listSubscriptions(\\n        ISuperfluidToken token,\\n        address subscriber)\\n            external\\n            view\\n            virtual\\n            returns(\\n                address[] memory publishers,\\n                uint32[] memory indexIds,\\n                uint128[] memory unitsList);\\n\\n    /**\\n     * @dev Delete the subscription of an user\\n     * @param token Super token address\\n     * @param publisher The publisher of the index\\n     * @param indexId Id of the index\\n     * @param subscriber The subscriber's address\\n     * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n     *\\n     * @custom:callbacks \\n     * - if the subscriber called it\\n     *   - AgreementTerminated callback to the publsiher:\\n     *      - agreementId is for the subscription\\n     * - if the publisher called it\\n     *   - AgreementTerminated callback to the subscriber:\\n     *      - agreementId is for the subscription\\n     */\\n    function deleteSubscription(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n            external\\n            virtual\\n            returns(bytes memory newCtx);\\n\\n    /**\\n    * @dev Claim pending distributions\\n    * @param token Super token address\\n    * @param publisher The publisher of the index\\n    * @param indexId Id of the index\\n    * @param subscriber The subscriber's address\\n    * @param ctx Context bytes (see ISuperfluid.sol for Context struct)\\n    *\\n    * @custom:note The subscription should not be approved yet\\n    *\\n    * @custom:callbacks \\n    * - AgreementUpdated callback to the publisher:\\n    *    - agreementId is for the subscription\\n    */\\n    function claim(\\n        ISuperfluidToken token,\\n        address publisher,\\n        uint32 indexId,\\n        address subscriber,\\n        bytes calldata ctx)\\n        external\\n        virtual\\n        returns(bytes memory newCtx);\\n    \\n    /**\\n      * @dev Index distribution claimed event\\n      * @param token Super token address\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param subscriber The subscriber units updated\\n      * @param amount The pending amount claimed\\n      */\\n    event IndexDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed publisher,\\n        uint32 indexed indexId,\\n        address subscriber,\\n        uint256 amount);\\n    \\n    /**\\n      * @dev Subscription distribution claimed event\\n      * @param token Super token address\\n      * @param subscriber The subscriber units updated\\n      * @param publisher Index publisher\\n      * @param indexId The specified indexId\\n      * @param amount The pending amount claimed\\n      */\\n    event SubscriptionDistributionClaimed(\\n        ISuperfluidToken indexed token,\\n        address indexed subscriber,\\n        address publisher,\\n        uint32 indexId,\\n        uint256 amount);\\n\\n}\\n\",\"keccak256\":\"0x7b088dfa11a00d2b1e6e0938978364a6918015b052a4bf3ffcc67db9b3182370\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/Definitions.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\n/**\\n * @title Super app definitions library\\n * @author Superfluid\\n */\\nlibrary SuperAppDefinitions {\\n\\n    /**************************************************************************\\n    / App manifest config word\\n    /**************************************************************************/\\n\\n    /*\\n     * App level is a way to allow the app to whitelist what other app it can\\n     * interact with (aka. composite app feature).\\n     *\\n     * For more details, refer to the technical paper of superfluid protocol.\\n     */\\n    uint256 constant internal APP_LEVEL_MASK = 0xFF;\\n\\n    // The app is at the final level, hence it doesn't want to interact with any other app\\n    uint256 constant internal APP_LEVEL_FINAL = 1 << 0;\\n\\n    // The app is at the second level, it may interact with other final level apps if whitelisted\\n    uint256 constant internal APP_LEVEL_SECOND = 1 << 1;\\n\\n    function getAppCallbackLevel(uint256 configWord) internal pure returns (uint8) {\\n        return uint8(configWord & APP_LEVEL_MASK);\\n    }\\n\\n    uint256 constant internal APP_JAIL_BIT = 1 << 15;\\n    function isAppJailed(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & SuperAppDefinitions.APP_JAIL_BIT) > 0;\\n    }\\n\\n    /**************************************************************************\\n    / Callback implementation bit masks\\n    /**************************************************************************/\\n    uint256 constant internal AGREEMENT_CALLBACK_NOOP_BITMASKS = 0xFF << 32;\\n    uint256 constant internal BEFORE_AGREEMENT_CREATED_NOOP = 1 << (32 + 0);\\n    uint256 constant internal AFTER_AGREEMENT_CREATED_NOOP = 1 << (32 + 1);\\n    uint256 constant internal BEFORE_AGREEMENT_UPDATED_NOOP = 1 << (32 + 2);\\n    uint256 constant internal AFTER_AGREEMENT_UPDATED_NOOP = 1 << (32 + 3);\\n    uint256 constant internal BEFORE_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 4);\\n    uint256 constant internal AFTER_AGREEMENT_TERMINATED_NOOP = 1 << (32 + 5);\\n\\n    /**************************************************************************\\n    / App Jail Reasons\\n    /**************************************************************************/\\n\\n    uint256 constant internal APP_RULE_REGISTRATION_ONLY_IN_CONSTRUCTOR = 1;\\n    uint256 constant internal APP_RULE_NO_REGISTRATION_FOR_EOA = 2;\\n    uint256 constant internal APP_RULE_NO_REVERT_ON_TERMINATION_CALLBACK = 10;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_SENDER_ACCOUNT = 11;\\n    uint256 constant internal APP_RULE_NO_CRITICAL_RECEIVER_ACCOUNT = 12;\\n    uint256 constant internal APP_RULE_CTX_IS_READONLY = 20;\\n    uint256 constant internal APP_RULE_CTX_IS_NOT_CLEAN = 21;\\n    uint256 constant internal APP_RULE_CTX_IS_MALFORMATED = 22;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_NOT_WHITELISTED = 30;\\n    uint256 constant internal APP_RULE_COMPOSITE_APP_IS_JAILED = 31;\\n    uint256 constant internal APP_RULE_MAX_APP_LEVEL_REACHED = 40;\\n\\n    // Validate configWord cleaness for future compatibility, or else may introduce undefined future behavior\\n    function isConfigWordClean(uint256 configWord) internal pure returns (bool) {\\n        return (configWord & ~(APP_LEVEL_MASK | APP_JAIL_BIT | AGREEMENT_CALLBACK_NOOP_BITMASKS)) == uint256(0);\\n    }\\n}\\n\\n/**\\n * @title Context definitions library\\n * @author Superfluid\\n */\\nlibrary ContextDefinitions {\\n\\n    /**************************************************************************\\n    / Call info\\n    /**************************************************************************/\\n\\n    // app level\\n    uint256 constant internal CALL_INFO_APP_LEVEL_MASK = 0xFF;\\n\\n    // call type\\n    uint256 constant internal CALL_INFO_CALL_TYPE_SHIFT = 32;\\n    uint256 constant internal CALL_INFO_CALL_TYPE_MASK = 0xF << CALL_INFO_CALL_TYPE_SHIFT;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_AGREEMENT = 1;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_ACTION = 2;\\n    uint8 constant internal CALL_INFO_CALL_TYPE_APP_CALLBACK = 3;\\n\\n    function decodeCallInfo(uint256 callInfo)\\n        internal pure\\n        returns (uint8 appCallbackLevel, uint8 callType)\\n    {\\n        appCallbackLevel = uint8(callInfo & CALL_INFO_APP_LEVEL_MASK);\\n        callType = uint8((callInfo & CALL_INFO_CALL_TYPE_MASK) >> CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n    function encodeCallInfo(uint8 appCallbackLevel, uint8 callType)\\n        internal pure\\n        returns (uint256 callInfo)\\n    {\\n        return uint256(appCallbackLevel) | (uint256(callType) << CALL_INFO_CALL_TYPE_SHIFT);\\n    }\\n\\n}\\n\\n/**\\n * @title Flow Operator definitions library\\n  * @author Superfluid\\n */\\n library FlowOperatorDefinitions {\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_CREATE = uint8(1) << 0;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_UPDATE = uint8(1) << 1;\\n    uint8 constant internal AUTHORIZE_FLOW_OPERATOR_DELETE = uint8(1) << 2;\\n    uint8 constant internal AUTHORIZE_FULL_CONTROL =\\n        AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE;\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_CREATE = ~(uint8(1) << 0);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_UPDATE = ~(uint8(1) << 1);\\n    uint8 constant internal REVOKE_FLOW_OPERATOR_DELETE = ~(uint8(1) << 2);\\n\\n    function isPermissionsClean(uint8 permissions) internal pure returns (bool) {\\n        return (\\n            permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE\\n                | AUTHORIZE_FLOW_OPERATOR_UPDATE\\n                | AUTHORIZE_FLOW_OPERATOR_DELETE)\\n            ) == uint8(0);\\n    }\\n }\\n\\n/**\\n * @title Batch operation library\\n * @author Superfluid\\n */\\nlibrary BatchOperation {\\n    /**\\n     * @dev ERC20.approve batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationApprove(\\n     *     abi.decode(data, (address spender, uint256 amount))\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_APPROVE = 1;\\n    /**\\n     * @dev ERC20.transferFrom batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationTransferFrom(\\n     *     abi.decode(data, (address sender, address recipient, uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC20_TRANSFER_FROM = 2;\\n    /**\\n     * @dev ERC777.send batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationSend(\\n     *     abi.decode(data, (address recipient, uint256 amount, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_ERC777_SEND = 3;\\n    /**\\n     * @dev SuperToken.upgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationUpgrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_UPGRADE = 1 + 100;\\n    /**\\n     * @dev SuperToken.downgrade batch operation type\\n     *\\n     * Call spec:\\n     * ISuperToken(target).operationDowngrade(\\n     *     abi.decode(data, (uint256 amount)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERTOKEN_DOWNGRADE = 2 + 100;\\n    /**\\n     * @dev Superfluid.callAgreement batch operation type\\n     *\\n     * Call spec:\\n     * callAgreement(\\n     *     ISuperAgreement(target)),\\n     *     abi.decode(data, (bytes callData, bytes userData)\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_AGREEMENT = 1 + 200;\\n    /**\\n     * @dev Superfluid.callAppAction batch operation type\\n     *\\n     * Call spec:\\n     * callAppAction(\\n     *     ISuperApp(target)),\\n     *     data\\n     * )\\n     */\\n    uint32 constant internal OPERATION_TYPE_SUPERFLUID_CALL_APP_ACTION = 2 + 200;\\n}\\n\\n/**\\n * @title Superfluid governance configs library\\n * @author Superfluid\\n */\\nlibrary SuperfluidGovernanceConfigs {\\n\\n    bytes32 constant internal SUPERFLUID_REWARD_ADDRESS_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.rewardAddress\\\");\\n    bytes32 constant internal CFAV1_PPP_CONFIG_KEY =\\n        keccak256(\\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1.PPPConfiguration\\\");\\n    bytes32 constant internal SUPERTOKEN_MINIMUM_DEPOSIT_KEY =\\n        keccak256(\\\"org.superfluid-finance.superfluid.superTokenMinimumDeposit\\\");\\n\\n    function getTrustedForwarderConfigKey(address forwarder) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.trustedForwarder\\\",\\n            forwarder));\\n    }\\n\\n    function getAppRegistrationConfigKey(address deployer, string memory registrationKey) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.registrationKey\\\",\\n            deployer,\\n            registrationKey));\\n    }\\n\\n    function getAppFactoryConfigKey(address factory) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n            \\\"org.superfluid-finance.superfluid.appWhiteListing.factory\\\",\\n            factory));\\n    }\\n\\n    function decodePPPConfig(uint256 pppConfig) internal pure returns (uint256 liquidationPeriod, uint256 patricianPeriod) {\\n        liquidationPeriod = (pppConfig >> 32) & type(uint32).max;\\n        patricianPeriod = pppConfig & type(uint32).max;\\n    }\\n}\\n\",\"keccak256\":\"0x9159d91dbcca7c54da425113fb9719a434abac5ca1c79612099ee22853646ddd\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperAgreement.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\n\\n/**\\n * @title Super agreement interface\\n * @author Superfluid\\n */\\ninterface ISuperAgreement {\\n\\n    /**\\n     * @dev Get the type of the agreement class\\n     */\\n    function agreementType() external view returns (bytes32);\\n\\n    /**\\n     * @dev Calculate the real-time balance for the account of this agreement class\\n     * @param account Account the state belongs to\\n     * @param time Time used for the calculation\\n     * @return dynamicBalance Dynamic balance portion of real-time balance of this agreement\\n     * @return deposit Account deposit amount of this agreement\\n     * @return owedDeposit Account owed deposit amount of this agreement\\n     */\\n    function realtimeBalanceOf(\\n        ISuperfluidToken token,\\n        address account,\\n        uint256 time\\n    )\\n        external\\n        view\\n        returns (\\n            int256 dynamicBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit\\n        );\\n\\n}\\n\",\"keccak256\":\"0x9b4fab6dcac1337f78e04d67d8c2b48b1de8bd4bbf14b475840f9dbda7b8f21e\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperApp.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\n/**\\n * @title SuperApp interface\\n * @author Superfluid\\n * @dev Be aware of the app being jailed, when the word permitted is used.\\n */\\ninterface ISuperApp {\\n\\n    /**\\n     * @dev Callback before a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n     * @dev Callback after a new agreement is created.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param cbdata The data returned from the before-hook callback.\\n     * @param ctx The context data.\\n     * @return newCtx The current context of the transaction.\\n     *\\n     * @custom:note \\n     * - State changes is permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function afterAgreementCreated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Callback before a new agreement is updated.\\n     * @param superToken The super token used for the agreement.\\n     * @param agreementClass The agreement class address.\\n     * @param agreementId The agreementId\\n     * @param agreementData The agreement data (non-compressed)\\n     * @param ctx The context data.\\n     * @return cbdata A free format in memory data the app can use to pass\\n     *          arbitary information to the after-hook callback.\\n     *\\n     * @custom:note \\n     * - It will be invoked with `staticcall`, no state changes are permitted.\\n     * - Only revert with a \\\"reason\\\" is permitted.\\n     */\\n    function beforeAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n\\n    /**\\n    * @dev Callback after a new agreement is updated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Only revert with a \\\"reason\\\" is permitted.\\n    */\\n    function afterAgreementUpdated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n\\n    /**\\n    * @dev Callback before a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param ctx The context data.\\n    * @return cbdata A free format in memory data the app can use to pass arbitary information to the after-hook callback.\\n    *\\n    * @custom:note \\n    * - It will be invoked with `staticcall`, no state changes are permitted.\\n    * - Revert is not permitted.\\n    */\\n    function beforeAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata ctx\\n    )\\n        external\\n        view\\n        returns (bytes memory cbdata);\\n\\n    /**\\n    * @dev Callback after a new agreement is terminated.\\n    * @param superToken The super token used for the agreement.\\n    * @param agreementClass The agreement class address.\\n    * @param agreementId The agreementId\\n    * @param agreementData The agreement data (non-compressed)\\n    * @param cbdata The data returned from the before-hook callback.\\n    * @param ctx The context data.\\n    * @return newCtx The current context of the transaction.\\n    *\\n    * @custom:note \\n    * - State changes is permitted.\\n    * - Revert is not permitted.\\n    */\\n    function afterAgreementTerminated(\\n        ISuperToken superToken,\\n        address agreementClass,\\n        bytes32 agreementId,\\n        bytes calldata agreementData,\\n        bytes calldata cbdata,\\n        bytes calldata ctx\\n    )\\n        external\\n        returns (bytes memory newCtx);\\n}\\n\",\"keccak256\":\"0x6cc4b0724d977190c7441dfc3be6c6e48b43b555c3370af32ef5b6600f15f53f\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Super token (Superfluid Token + ERC20 + ERC777) interface\\n * @author Superfluid\\n */\\ninterface ISuperToken is ISuperfluidToken, TokenInfo, IERC20, IERC777 {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_CALLER_IS_NOT_OPERATOR_FOR_HOLDER();       // 0xf7f02227\\n    error SUPER_TOKEN_NOT_ERC777_TOKENS_RECIPIENT();             // 0xfe737d05\\n    error SUPER_TOKEN_INFLATIONARY_DEFLATIONARY_NOT_SUPPORTED(); // 0xe3e13698\\n    error SUPER_TOKEN_NO_UNDERLYING_TOKEN();                     // 0xf79cf656\\n    error SUPER_TOKEN_ONLY_SELF();                               // 0x7ffa6648\\n    error SUPER_TOKEN_ONLY_HOST();                               // 0x98f73704\\n    error SUPER_TOKEN_APPROVE_FROM_ZERO_ADDRESS();               // 0x81638627\\n    error SUPER_TOKEN_APPROVE_TO_ZERO_ADDRESS();                 // 0xdf070274\\n    error SUPER_TOKEN_BURN_FROM_ZERO_ADDRESS();                  // 0xba2ab184\\n    error SUPER_TOKEN_MINT_TO_ZERO_ADDRESS();                    // 0x0d243157\\n    error SUPER_TOKEN_TRANSFER_FROM_ZERO_ADDRESS();              // 0xeecd6c9b\\n    error SUPER_TOKEN_TRANSFER_TO_ZERO_ADDRESS();                // 0xe219bd39\\n\\n    /**\\n     * @dev Initialize the contract\\n     */\\n    function initialize(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        string calldata n,\\n        string calldata s\\n    ) external;\\n\\n    /**************************************************************************\\n    * TokenInfo & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view override(IERC777, TokenInfo) returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * @custom:note SuperToken always uses 18 decimals.\\n     *\\n     * This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view override(TokenInfo) returns (uint8);\\n\\n    /**************************************************************************\\n    * ERC20 & ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address account) external view override(IERC777, IERC20) returns(uint256 balance);\\n\\n    /**************************************************************************\\n    * ERC20\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     *         allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     *         zero by default.\\n     *\\n     * @notice This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external override(IERC20) view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:note Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * @custom:emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     *         allowance mechanism. `amount` is then deducted from the caller's\\n     *         allowance.\\n     *\\n     * @return Returns Success a boolean value indicating whether the operation succeeded.\\n     *\\n     * @custom:emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external override(IERC20) returns (bool);\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * @custom:emits an {Approval} event indicating the updated allowance.\\n     *\\n     * @custom:requirements \\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**************************************************************************\\n    * ERC777\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     *         means all token operations (creation, movement and destruction) must have\\n     *         amounts that are a multiple of this number.\\n     *\\n     * @custom:note For super token contracts, this value is always 1\\n     */\\n    function granularity() external view override(IERC777) returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * @dev If send or receive hooks are registered for the caller and `recipient`,\\n     *      the corresponding functions will be called with `data` and empty\\n     *      `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(address recipient, uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply and transfers the underlying token to the caller's account.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external override(IERC777);\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external override(IERC777) view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * @custom:emits an {AuthorizedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * @custom:emits a {RevokedOperator} event.\\n     *\\n     * @custom:requirements \\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external override(IERC777);\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external override(IERC777) view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * @custom:emits a {Sent} event.\\n     *\\n     * @custom:requirements \\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * @custom:emits a {Burned} event.\\n     *\\n     * @custom:requirements \\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external override(IERC777);\\n\\n    /**************************************************************************\\n     * SuperToken custom token functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Mint new tokens for the account\\n     *\\n     * @custom:modifiers \\n     *  - onlySelf\\n     */\\n    function selfMint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData\\n    ) external;\\n\\n   /**\\n    * @dev Burn existing tokens for the account\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfBurn(\\n       address account,\\n       uint256 amount,\\n       bytes memory userData\\n   ) external;\\n\\n   /**\\n    * @dev Transfer `amount` tokens from the `sender` to `recipient`.\\n    * If `spender` isn't the same as `sender`, checks if `spender` has allowance to\\n    * spend tokens of `sender`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfTransferFrom(\\n        address sender,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n   ) external;\\n\\n   /**\\n    * @dev Give `spender`, `amount` allowance to spend the tokens of\\n    * `account`.\\n    *\\n    * @custom:modifiers \\n    *  - onlySelf\\n    */\\n   function selfApproveFor(\\n        address account,\\n        address spender,\\n        uint256 amount\\n   ) external;\\n\\n    /**************************************************************************\\n     * SuperToken extra functions\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Transfer all available balance from `msg.sender` to `recipient`\\n     */\\n    function transferAll(address recipient) external;\\n\\n    /**************************************************************************\\n     * ERC20 wrapping\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Return the underlying token contract\\n     * @return tokenAddr Underlying token address\\n     */\\n    function getUnderlyingToken() external view returns(address tokenAddr);\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken.\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     */\\n    function upgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Upgrade ERC20 to SuperToken and transfer immediately\\n     * @param to The account to receive upgraded tokens\\n     * @param amount Number of tokens to be upgraded (in 18 decimals)\\n     * @param data User data for the TokensRecipient callback\\n     *\\n     * @custom:note It will use `transferFrom` to get tokens. Before calling this\\n     * function you should `approve` this contract\\n     * \\n     * @custom:warning\\n     * - there is potential of reentrancy IF the \\\"to\\\" account is a registered ERC777 recipient.\\n     * @custom:requirements \\n     * - if `data` is NOT empty AND `to` is a contract, it MUST be a registered ERC777 recipient otherwise it reverts.\\n     */\\n    function upgradeTo(address to, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Token upgrade event\\n     * @param account Account where tokens are upgraded to\\n     * @param amount Amount of tokens upgraded (in 18 decimals)\\n     */\\n    event TokenUpgraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20.\\n     * @dev It will call transfer to send tokens\\n     * @param amount Number of tokens to be downgraded\\n     */\\n    function downgrade(uint256 amount) external;\\n\\n    /**\\n     * @dev Downgrade SuperToken to ERC20 and transfer immediately\\n     * @param to The account to receive downgraded tokens\\n     * @param amount Number of tokens to be downgraded (in 18 decimals)\\n     */\\n    function downgradeTo(address to, uint256 amount) external;\\n\\n    /**\\n     * @dev Token downgrade event\\n     * @param account Account whose tokens are downgraded\\n     * @param amount Amount of tokens downgraded\\n     */\\n    event TokenDowngraded(\\n        address indexed account,\\n        uint256 amount\\n    );\\n\\n    /**************************************************************************\\n    * Batch Operations\\n    *************************************************************************/\\n\\n    /**\\n    * @dev Perform ERC20 approve by host contract.\\n    * @param account The account owner to be approved.\\n    * @param spender The spender of account owner's funds.\\n    * @param amount Number of tokens to be approved.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationApprove(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC20 transferFrom by host contract.\\n    * @param account The account to spend sender's funds.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationTransferFrom(\\n        address account,\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n    * @dev Perform ERC777 send by host contract.\\n    * @param spender The account where the funds is sent from.\\n    * @param recipient The recipient of the funds.\\n    * @param amount Number of tokens to be transferred.\\n    * @param data Arbitrary user inputted data\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationSend(\\n        address spender,\\n        address recipient,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n    * @dev Upgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be upgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationUpgrade(address account, uint256 amount) external;\\n\\n    /**\\n    * @dev Downgrade ERC20 to SuperToken by host contract.\\n    * @param account The account to be changed.\\n    * @param amount Number of tokens to be downgraded (in 18 decimals)\\n    *\\n    * @custom:modifiers \\n    *  - onlyHost\\n    */\\n    function operationDowngrade(address account, uint256 amount) external;\\n\\n\\n    /**************************************************************************\\n    * Function modifiers for access control and parameter validations\\n    *\\n    * While they cannot be explicitly stated in function definitions, they are\\n    * listed in function definition comments instead for clarity.\\n    *\\n    * NOTE: solidity-coverage not supporting it\\n    *************************************************************************/\\n\\n    /// @dev The msg.sender must be the contract itself\\n    //modifier onlySelf() virtual\\n\\n}\\n\",\"keccak256\":\"0xa65d8a5c3b50d4477f04db3617f6e872137154a3004bca1fcd4702f80c5fdc62\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperTokenFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\n\\nimport {\\n    IERC20,\\n    ERC20WithTokenInfo\\n} from \\\"../tokens/ERC20WithTokenInfo.sol\\\";\\n\\n/**\\n * @title Super token factory interface\\n * @author Superfluid\\n */\\ninterface ISuperTokenFactory {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SUPER_TOKEN_FACTORY_ALREADY_EXISTS(); // 0x91d67972\\n    error SUPER_TOKEN_FACTORY_DOES_NOT_EXIST(); // 0x872cac48\\n    error SUPER_TOKEN_FACTORY_UNINITIALIZED();  // 0x1b39b9b4\\n    error SUPER_TOKEN_FACTORY_ONLY_HOST();      // 0x478b8e83\\n    error SUPER_TOKEN_FACTORY_ZERO_ADDRESS();   // 0x305c9e82\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /// @dev Initialize the contract\\n    function initialize() external;\\n\\n    /**\\n     * @dev Get the current super token logic used by the factory\\n     */\\n    function getSuperTokenLogic() external view returns (ISuperToken superToken);\\n\\n    /**\\n     * @dev Upgradability modes\\n     */\\n    enum Upgradability {\\n        /// Non upgradable super token, `host.updateSuperTokenLogic` will revert\\n        NON_UPGRADABLE,\\n        /// Upgradable through `host.updateSuperTokenLogic` operation\\n        SEMI_UPGRADABLE,\\n        /// Always using the latest super token logic\\n        FULL_UPGRADABLE\\n    }\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param underlyingDecimals Underlying token decimals\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     */\\n    function createERC20Wrapper(\\n        IERC20 underlyingToken,\\n        uint8 underlyingDecimals,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Create new super token wrapper for the underlying ERC20 token with extra token info\\n     * @param underlyingToken Underlying ERC20 token\\n     * @param upgradability Upgradability mode\\n     * @param name Super token name\\n     * @param symbol Super token symbol\\n     * @return superToken The deployed and initialized wrapper super token\\n     * NOTE:\\n     * - It assumes token provide the .decimals() function\\n     */\\n    function createERC20Wrapper(\\n        ERC20WithTokenInfo underlyingToken,\\n        Upgradability upgradability,\\n        string calldata name,\\n        string calldata symbol\\n    )\\n        external\\n        returns (ISuperToken superToken);\\n\\n    /**\\n     * @notice Creates a wrapper super token AND sets it in the canonical list OR reverts if it already exists\\n     * @dev salt for create2 is the keccak256 hash of abi.encode(address(_underlyingToken))\\n     * @param _underlyingToken Underlying ERC20 token\\n     * @return ISuperToken the created supertoken\\n     */\\n    function createCanonicalERC20Wrapper(ERC20WithTokenInfo _underlyingToken)\\n        external\\n        returns (ISuperToken);\\n\\n    /**\\n     * @notice Computes/Retrieves wrapper super token address given the underlying token address\\n     * @dev We return from our canonical list if it already exists, otherwise we compute it\\n     * @dev note that this function only computes addresses for SEMI_UPGRADABLE SuperTokens\\n     * @param _underlyingToken Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     * @return isDeployed whether the super token is deployed AND set in the canonical mapping\\n     */\\n    function computeCanonicalERC20WrapperAddress(address _underlyingToken)\\n        external\\n        view\\n        returns (address superTokenAddress, bool isDeployed);\\n\\n    /**\\n     * @notice Gets the canonical ERC20 wrapper super token address given the underlying token address\\n     * @dev We return the address if it exists and the zero address otherwise\\n     * @param _underlyingTokenAddress Underlying ERC20 token address\\n     * @return superTokenAddress Super token address\\n     */\\n    function getCanonicalERC20Wrapper(address _underlyingTokenAddress)\\n        external\\n        view\\n        returns (address superTokenAddress);\\n\\n    /**\\n     * @dev Creates a new custom super token\\n     * @param customSuperTokenProxy address of the custom supertoken proxy\\n     */\\n    function initializeCustomSuperToken(\\n        address customSuperTokenProxy\\n    )\\n        external;\\n\\n    /**\\n      * @dev Super token logic created event\\n      * @param tokenLogic Token logic address\\n      */\\n    event SuperTokenLogicCreated(ISuperToken indexed tokenLogic);\\n\\n    /**\\n      * @dev Super token created event\\n      * @param token Newly created super token address\\n      */\\n    event SuperTokenCreated(ISuperToken indexed token);\\n\\n    /**\\n      * @dev Custom super token created event\\n      * @param token Newly created custom super token address\\n      */\\n    event CustomSuperTokenCreated(ISuperToken indexed token);\\n\\n}\\n\",\"keccak256\":\"0x316aa6cd16167569d5ee47fb2e4673b1def2117c7ea56969290ab6aec97cd263\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperfluidGovernance } from \\\"./ISuperfluidGovernance.sol\\\";\\nimport { ISuperfluidToken } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperTokenFactory } from \\\"./ISuperTokenFactory.sol\\\";\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperApp } from \\\"./ISuperApp.sol\\\";\\nimport {\\n    BatchOperation,\\n    ContextDefinitions,\\n    FlowOperatorDefinitions,\\n    SuperAppDefinitions,\\n    SuperfluidGovernanceConfigs\\n} from \\\"./Definitions.sol\\\";\\nimport { TokenInfo } from \\\"../tokens/TokenInfo.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC777 } from \\\"@openzeppelin/contracts/token/ERC777/IERC777.sol\\\";\\n\\n/**\\n * @title Host interface\\n * @author Superfluid\\n * @notice This is the central contract of the system where super agreement, super app\\n * and super token features are connected.\\n *\\n * The Superfluid host contract is also the entry point for the protocol users,\\n * where batch call and meta transaction are provided for UX improvements.\\n *\\n */\\ninterface ISuperfluid {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    // Superfluid Custom Errors\\n    error HOST_AGREEMENT_CALLBACK_IS_NOT_ACTION();              // 0xef4295f6\\n    error HOST_CANNOT_DOWNGRADE_TO_NON_UPGRADEABLE();           // 0x474e7641\\n    error HOST_CALL_AGREEMENT_WITH_CTX_FROM_WRONG_ADDRESS();    // 0x0cd0ebc2\\n    error HOST_CALL_APP_ACTION_WITH_CTX_FROM_WRONG_ADDRESS();   // 0x473f7bd4\\n    error HOST_INVALID_CONFIG_WORD();                           // 0xf4c802a4\\n    error HOST_MAX_256_AGREEMENTS();                            // 0x7c281a78\\n    error HOST_NON_UPGRADEABLE();                               // 0x14f72c9f\\n    error HOST_NON_ZERO_LENGTH_PLACEHOLDER_CTX();               // 0x67e9985b\\n    error HOST_ONLY_GOVERNANCE();                               // 0xc5d22a4e\\n    error HOST_UNKNOWN_BATCH_CALL_OPERATION_TYPE();             // 0xb4770115\\n    error HOST_AGREEMENT_ALREADY_REGISTERED();                  // 0xdc9ddba8\\n    error HOST_AGREEMENT_IS_NOT_REGISTERED();                   // 0x1c9e9bea\\n    error HOST_MUST_BE_CONTRACT();                              // 0xd4f6b30c\\n    error HOST_ONLY_LISTED_AGREEMENT();                         // 0x619c5359\\n\\n    // App Related Custom Errors\\n    // uses SuperAppDefinitions' App Jail Reasons as _code\\n    error APP_RULE(uint256 _code);                              // 0xa85ba64f\\n\\n    error HOST_INVALID_OR_EXPIRED_SUPER_APP_REGISTRATION_KEY(); // 0x19ab84d1\\n    error HOST_NOT_A_SUPER_APP();                               // 0x163cbe43\\n    error HOST_NO_APP_REGISTRATION_PERMISSIONS();               // 0x5b93ebf0\\n    error HOST_RECEIVER_IS_NOT_SUPER_APP();                     // 0x96aa315e\\n    error HOST_SENDER_IS_NOT_SUPER_APP();                       // 0xbacfdc40\\n    error HOST_SOURCE_APP_NEEDS_HIGHER_APP_LEVEL();             // 0x44725270\\n    error HOST_SUPER_APP_IS_JAILED();                           // 0x02384b64\\n    error HOST_SUPER_APP_ALREADY_REGISTERED();                  // 0x01b0a935\\n    error HOST_UNAUTHORIZED_SUPER_APP_FACTORY();                // 0x289533c5\\n\\n    /**************************************************************************\\n     * Time\\n     *\\n     * > The Oracle: You have the sight now, Neo. You are looking at the world without time.\\n     * > Neo: Then why can't I see what happens to her?\\n     * > The Oracle: We can never see past the choices we don't understand.\\n     * >       - The Oracle and Neo conversing about the future of Trinity and the effects of Neo's choices\\n     *************************************************************************/\\n\\n    function getNow() external view returns (uint256);\\n\\n    /**************************************************************************\\n     * Governance\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get the current governance address of the Superfluid host\\n     */\\n    function getGovernance() external view returns(ISuperfluidGovernance governance);\\n\\n    /**\\n     * @dev Replace the current governance with a new one\\n     */\\n    function replaceGovernance(ISuperfluidGovernance newGov) external;\\n    /**\\n     * @dev Governance replaced event\\n     * @param oldGov Address of the old governance contract\\n     * @param newGov Address of the new governance contract\\n     */\\n    event GovernanceReplaced(ISuperfluidGovernance oldGov, ISuperfluidGovernance newGov);\\n\\n    /**************************************************************************\\n     * Agreement Whitelisting\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Register a new agreement class to the system\\n     * @param agreementClassLogic Initial agreement class code\\n     *\\n     * @custom:modifiers \\n     * - onlyGovernance\\n     */\\n    function registerAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class registered event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type registered\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassRegistered(bytes32 agreementType, address code);\\n\\n    /**\\n    * @dev Update code of an agreement class\\n    * @param agreementClassLogic New code for the agreement class\\n    *\\n    * @custom:modifiers \\n    *  - onlyGovernance\\n    */\\n    function updateAgreementClass(ISuperAgreement agreementClassLogic) external;\\n    /**\\n     * @notice Agreement class updated event\\n     * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n     * @param agreementType The agreement type updated\\n     * @param code Address of the new agreement\\n     */\\n    event AgreementClassUpdated(bytes32 agreementType, address code);\\n\\n    /**\\n    * @notice Check if the agreement type is whitelisted\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function isAgreementTypeListed(bytes32 agreementType) external view returns(bool yes);\\n\\n    /**\\n    * @dev Check if the agreement class is whitelisted\\n    */\\n    function isAgreementClassListed(ISuperAgreement agreementClass) external view returns(bool yes);\\n\\n    /**\\n    * @notice Get agreement class\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    */\\n    function getAgreementClass(bytes32 agreementType) external view returns(ISuperAgreement agreementClass);\\n\\n    /**\\n    * @dev Map list of the agreement classes using a bitmap\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function mapAgreementClasses(uint256 bitmap)\\n        external view\\n        returns (ISuperAgreement[] memory agreementClasses);\\n\\n    /**\\n    * @notice Create a new bitmask by adding a agreement class to it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function addToAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**\\n    * @notice Create a new bitmask by removing a agreement class from it\\n    * @dev agreementType is the keccak256 hash of: \\\"org.superfluid-finance.agreements.<AGREEMENT_NAME>.<VERSION>\\\"\\n    * @param bitmap Agreement class bitmap\\n    */\\n    function removeFromAgreementClassesBitmap(uint256 bitmap, bytes32 agreementType)\\n        external view\\n        returns (uint256 newBitmap);\\n\\n    /**************************************************************************\\n    * Super Token Factory\\n    **************************************************************************/\\n\\n    /**\\n     * @dev Get the super token factory\\n     * @return factory The factory\\n     */\\n    function getSuperTokenFactory() external view returns (ISuperTokenFactory factory);\\n\\n    /**\\n     * @dev Get the super token factory logic (applicable to upgradable deployment)\\n     * @return logic The factory logic\\n     */\\n    function getSuperTokenFactoryLogic() external view returns (address logic);\\n\\n    /**\\n     * @dev Update super token factory\\n     * @param newFactory New factory logic\\n     */\\n    function updateSuperTokenFactory(ISuperTokenFactory newFactory) external;\\n    /**\\n     * @dev SuperToken factory updated event\\n     * @param newFactory Address of the new factory\\n     */\\n    event SuperTokenFactoryUpdated(ISuperTokenFactory newFactory);\\n\\n    /**\\n     * @notice Update the super token logic to the latest\\n     * @dev Refer to ISuperTokenFactory.Upgradability for expected behaviours\\n     */\\n    function updateSuperTokenLogic(ISuperToken token) external;\\n    /**\\n     * @dev SuperToken logic updated event\\n     * @param code Address of the new SuperToken logic\\n     */\\n    event SuperTokenLogicUpdated(ISuperToken indexed token, address code);\\n\\n    /**************************************************************************\\n     * App Registry\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares itself as a super app.\\n     * @custom:deprecated you should use `registerAppWithKey` or `registerAppByFactory` instead,\\n     * because app registration is currently governance permissioned on mainnets.\\n     * @param configWord The super app manifest configuration, flags are defined in\\n     * `SuperAppDefinitions`\\n     */\\n    function registerApp(uint256 configWord) external;\\n    /**\\n     * @dev App registered event\\n     * @param app Address of jailed app\\n     */\\n    event AppRegistered(ISuperApp indexed app);\\n\\n    /**\\n     * @dev Message sender declares itself as a super app.\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @param registrationKey The registration key issued by the governance, needed to register on a mainnet.\\n     * @notice See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     * On testnets or in dev environment, a placeholder (e.g. empty string) can be used.\\n     * While the message sender must be the super app itself, the transaction sender (tx.origin)\\n     * must be the deployer account the registration key was issued for.\\n     */\\n    function registerAppWithKey(uint256 configWord, string calldata registrationKey) external;\\n\\n    /**\\n     * @dev Message sender (must be a contract) declares app as a super app\\n     * @param configWord The super app manifest configuration, flags are defined in `SuperAppDefinitions`\\n     * @notice On mainnet deployments, only factory contracts pre-authorized by governance can use this.\\n     * See https://github.com/superfluid-finance/protocol-monorepo/wiki/Super-App-White-listing-Guide\\n     */\\n    function registerAppByFactory(ISuperApp app, uint256 configWord) external;\\n\\n    /**\\n     * @dev Query if the app is registered\\n     * @param app Super app address\\n     */\\n    function isApp(ISuperApp app) external view returns(bool);\\n\\n    /**\\n     * @dev Query app callbacklevel\\n     * @param app Super app address\\n     */\\n    function getAppCallbackLevel(ISuperApp app) external view returns(uint8 appCallbackLevel);\\n\\n    /**\\n     * @dev Get the manifest of the super app\\n     * @param app Super app address\\n     */\\n    function getAppManifest(\\n        ISuperApp app\\n    )\\n        external view\\n        returns (\\n            bool isSuperApp,\\n            bool isJailed,\\n            uint256 noopMask\\n        );\\n\\n    /**\\n     * @dev Query if the app has been jailed\\n     * @param app Super app address\\n     */\\n    function isAppJailed(ISuperApp app) external view returns (bool isJail);\\n\\n    /**\\n     * @dev Whitelist the target app for app composition for the source app (msg.sender)\\n     * @param targetApp The target super app address\\n     */\\n    function allowCompositeApp(ISuperApp targetApp) external;\\n\\n    /**\\n     * @dev Query if source app is allowed to call the target app as downstream app\\n     * @param app Super app address\\n     * @param targetApp The target super app address\\n     */\\n    function isCompositeAppAllowed(\\n        ISuperApp app,\\n        ISuperApp targetApp\\n    )\\n        external view\\n        returns (bool isAppAllowed);\\n\\n    /**************************************************************************\\n     * Agreement Framework\\n     *\\n     * Agreements use these function to trigger super app callbacks, updates\\n     * app credit and charge gas fees.\\n     *\\n     * These functions can only be called by registered agreements.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev (For agreements) StaticCall the app before callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return cbdata            Data returned from the callback.\\n     */\\n    function callAppBeforeCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory cbdata);\\n\\n    /**\\n     * @dev (For agreements) Call the app after callback\\n     * @param  app               The super app.\\n     * @param  callData          The call data sending to the super app.\\n     * @param  isTermination     Is it a termination callback?\\n     * @param  ctx               Current ctx, it will be validated.\\n     * @return newCtx            The current context of the transaction.\\n     */\\n    function callAppAfterCallback(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bool isTermination,\\n        bytes calldata ctx\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns(bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Create a new callback stack\\n     * @param  ctx                     The current ctx, it will be validated.\\n     * @param  app                     The super app.\\n     * @param  appCreditGranted        App credit granted so far.\\n     * @param  appCreditUsed           App credit used so far.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function appCallbackPush(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 appCreditGranted,\\n        int256 appCreditUsed,\\n        ISuperfluidToken appCreditToken\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Pop from the current app callback stack\\n     * @param  ctx                     The ctx that was pushed before the callback stack.\\n     * @param  appCreditUsedDelta      App credit used by the app.\\n     * @return newCtx                  The current context of the transaction.\\n     *\\n     * @custom:security\\n     * - Here we cannot do assertValidCtx(ctx), since we do not really save the stack in memory.\\n     * - Hence there is still implicit trust that the agreement handles the callback push/pop pair correctly.\\n     */\\n    function appCallbackPop(\\n        bytes calldata ctx,\\n        int256 appCreditUsedDelta\\n    )\\n        external\\n        // onlyAgreement\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Use app credit.\\n     * @param  ctx                      The current ctx, it will be validated.\\n     * @param  appCreditUsedMore        See app credit for more details.\\n     * @return newCtx                   The current context of the transaction.\\n     */\\n    function ctxUseCredit(\\n        bytes calldata ctx,\\n        int256 appCreditUsedMore\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev (For agreements) Jail the app.\\n     * @param  app                     The super app.\\n     * @param  reason                  Jail reason code.\\n     * @return newCtx                  The current context of the transaction.\\n     */\\n    function jailApp(\\n        bytes calldata ctx,\\n        ISuperApp app,\\n        uint256 reason\\n    )\\n        external\\n        // onlyAgreement\\n        // assertValidCtx(ctx)\\n        returns (bytes memory newCtx);\\n\\n    /**\\n     * @dev Jail event for the app\\n     * @param app Address of jailed app\\n     * @param reason Reason the app is jailed (see Definitions.sol for the full list)\\n     */\\n    event Jail(ISuperApp indexed app, uint256 reason);\\n\\n    /**************************************************************************\\n     * Contextless Call Proxies\\n     *\\n     * NOTE: For EOAs or non-app contracts, they are the entry points for interacting\\n     * with agreements or apps.\\n     *\\n     * NOTE: The contextual call data should be generated using\\n     * abi.encodeWithSelector. The context parameter should be set to \\\"0x\\\",\\n     * an empty bytes array as a placeholder to be replaced by the host\\n     * contract.\\n     *************************************************************************/\\n\\n     /**\\n      * @dev Call agreement function\\n      * @param agreementClass The agreement address you are calling\\n      * @param callData The contextual call data with placeholder ctx\\n      * @param userData Extra user data being sent to the super app callbacks\\n      */\\n     function callAgreement(\\n         ISuperAgreement agreementClass,\\n         bytes calldata callData,\\n         bytes calldata userData\\n     )\\n        external\\n        //cleanCtx\\n        //isAgreement(agreementClass)\\n        returns(bytes memory returnedData);\\n\\n    /**\\n     * @notice Call app action\\n     * @dev Main use case is calling app action in a batch call via the host\\n     * @param callData The contextual call data\\n     *\\n     * @custom:note See \\\"Contextless Call Proxies\\\" above for more about contextual call data.\\n     */\\n    function callAppAction(\\n        ISuperApp app,\\n        bytes calldata callData\\n    )\\n        external\\n        //cleanCtx\\n        //isAppActive(app)\\n        //isValidAppAction(callData)\\n        returns(bytes memory returnedData);\\n\\n    /**************************************************************************\\n     * Contextual Call Proxies and Context Utilities\\n     *\\n     * For apps, they must use context they receive to interact with\\n     * agreements or apps.\\n     *\\n     * The context changes must be saved and returned by the apps in their\\n     * callbacks always, any modification to the context will be detected and\\n     * the violating app will be jailed.\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Context Struct\\n     *\\n     * @custom:note on backward compatibility:\\n     * - Non-dynamic fields are padded to 32bytes and packed\\n     * - Dynamic fields are referenced through a 32bytes offset to their \\\"parents\\\" field (or root)\\n     * - The order of the fields hence should not be rearranged in order to be backward compatible:\\n     *    - non-dynamic fields will be parsed at the same memory location,\\n     *    - and dynamic fields will simply have a greater offset than it was.\\n     * - We cannot change the structure of the Context struct because of ABI compatibility requirements\\n     */\\n    struct Context {\\n        //\\n        // Call context\\n        //\\n        // app callback level\\n        uint8 appCallbackLevel;\\n        // type of call\\n        uint8 callType;\\n        // the system timestamp\\n        uint256 timestamp;\\n        // The intended message sender for the call\\n        address msgSender;\\n\\n        //\\n        // Callback context\\n        //\\n        // For callbacks it is used to know which agreement function selector is called\\n        bytes4 agreementSelector;\\n        // User provided data for app callbacks\\n        bytes userData;\\n\\n        //\\n        // App context\\n        //\\n        // app credit granted\\n        uint256 appCreditGranted;\\n        // app credit wanted by the app callback\\n        uint256 appCreditWantedDeprecated;\\n        // app credit used, allowing negative values over a callback session\\n        // the appCreditUsed value over a callback sessions is calculated with:\\n        // existing flow data owed deposit + sum of the callback agreements\\n        // deposit deltas \\n        // the final value used to modify the state is determined by the\\n        // _adjustNewAppCreditUsed function (in AgreementLibrary.sol) which takes \\n        // the appCreditUsed value reached in the callback session and the app\\n        // credit granted\\n        int256 appCreditUsed;\\n        // app address\\n        address appAddress;\\n        // app credit in super token\\n        ISuperfluidToken appCreditToken;\\n    }\\n\\n    function callAgreementWithContext(\\n        ISuperAgreement agreementClass,\\n        bytes calldata callData,\\n        bytes calldata userData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // onlyAgreement(agreementClass)\\n        returns (bytes memory newCtx, bytes memory returnedData);\\n\\n    function callAppActionWithContext(\\n        ISuperApp app,\\n        bytes calldata callData,\\n        bytes calldata ctx\\n    )\\n        external\\n        // requireValidCtx(ctx)\\n        // isAppActive(app)\\n        returns (bytes memory newCtx);\\n\\n    function decodeCtx(bytes memory ctx)\\n        external pure\\n        returns (Context memory context);\\n\\n    function isCtxValid(bytes calldata ctx) external view returns (bool);\\n\\n    /**************************************************************************\\n    * Batch call\\n    **************************************************************************/\\n    /**\\n     * @dev Batch operation data\\n     */\\n    struct Operation {\\n        // Operation type. Defined in BatchOperation (Definitions.sol)\\n        uint32 operationType;\\n        // Operation target\\n        address target;\\n        // Data specific to the operation\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Batch call function\\n     * @param operations Array of batch operations\\n     */\\n    function batchCall(Operation[] calldata operations) external;\\n\\n    /**\\n     * @dev Batch call function for trusted forwarders (EIP-2771)\\n     * @param operations Array of batch operations\\n     */\\n    function forwardBatchCall(Operation[] calldata operations) external;\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * TODO: turning these off because solidity-coverage doesn't like it\\n     *************************************************************************/\\n\\n     /* /// @dev The current superfluid context is clean.\\n     modifier cleanCtx() virtual;\\n\\n     /// @dev Require the ctx being valid.\\n     modifier requireValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev Assert the ctx being valid.\\n     modifier assertValidCtx(bytes memory ctx) virtual;\\n\\n     /// @dev The agreement is a listed agreement.\\n     modifier isAgreement(ISuperAgreement agreementClass) virtual;\\n\\n     // onlyGovernance\\n\\n     /// @dev The msg.sender must be a listed agreement.\\n     modifier onlyAgreement() virtual;\\n\\n     /// @dev The app is registered and not jailed.\\n     modifier isAppActive(ISuperApp app) virtual; */\\n}\\n\",\"keccak256\":\"0xab9dab941f99d0f0ef6125fb6eafde03378d7c3e94e613dd12fb7fbf594c3373\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidGovernance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\nimport { ISuperToken } from \\\"./ISuperToken.sol\\\";\\nimport { ISuperfluidToken  } from \\\"./ISuperfluidToken.sol\\\";\\nimport { ISuperfluid } from \\\"./ISuperfluid.sol\\\";\\n\\n\\n/**\\n * @title Superfluid governance interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidGovernance {\\n    \\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_GOV_ARRAYS_NOT_SAME_LENGTH();                  // 0x27743aa6\\n    error SF_GOV_INVALID_LIQUIDATION_OR_PATRICIAN_PERIOD(); // 0xe171980a\\n    error SF_GOV_MUST_BE_CONTRACT();                        // 0x80dddd73\\n\\n    /**\\n     * @dev Replace the current governance with a new governance\\n     */\\n    function replaceGovernance(\\n        ISuperfluid host,\\n        address newGov) external;\\n\\n    /**\\n     * @dev Register a new agreement class\\n     */\\n    function registerAgreementClass(\\n        ISuperfluid host,\\n        address agreementClass) external;\\n\\n    /**\\n     * @dev Update logics of the contracts\\n     *\\n     * @custom:note \\n     * - Because they might have inter-dependencies, it is good to have one single function to update them all\\n     */\\n    function updateContracts(\\n        ISuperfluid host,\\n        address hostNewLogic,\\n        address[] calldata agreementClassNewLogics,\\n        address superTokenFactoryNewLogic\\n    ) external;\\n\\n    /**\\n     * @dev Update supertoken logic contract to the latest that is managed by the super token factory\\n     */\\n    function batchUpdateSuperTokenLogic(\\n        ISuperfluid host,\\n        ISuperToken[] calldata tokens) external;\\n    \\n    /**\\n     * @dev Set configuration as address value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        address value\\n    ) external;\\n    \\n    /**\\n     * @dev Set configuration as uint256 value\\n     */\\n    function setConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Clear configuration\\n     */\\n    function clearConfig(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key\\n    ) external;\\n\\n    /**\\n     * @dev Get configuration as address value\\n     */\\n    function getConfigAsAddress(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (address value);\\n\\n    /**\\n     * @dev Get configuration as uint256 value\\n     */\\n    function getConfigAsUint256(\\n        ISuperfluid host,\\n        ISuperfluidToken superToken,\\n        bytes32 key) external view returns (uint256 value);\\n\\n}\\n\",\"keccak256\":\"0x90a9259d0f0bb6b1bb6d48f051277eb75df96a9fbe684a203a3a468ad19318e2\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { ISuperAgreement } from \\\"./ISuperAgreement.sol\\\";\\n\\n/**\\n * @title Superfluid token interface\\n * @author Superfluid\\n */\\ninterface ISuperfluidToken {\\n\\n    /**************************************************************************\\n     * Errors\\n     *************************************************************************/\\n    error SF_TOKEN_AGREEMENT_ALREADY_EXISTS();  // 0xf05521f6\\n    error SF_TOKEN_AGREEMENT_DOES_NOT_EXIST();  // 0xdae18809\\n    error SF_TOKEN_BURN_INSUFFICIENT_BALANCE(); // 0x10ecdf44\\n    error SF_TOKEN_MOVE_INSUFFICIENT_BALANCE(); // 0x2f4cb941\\n    error SF_TOKEN_ONLY_LISTED_AGREEMENT();     // 0xc9ff6644\\n    error SF_TOKEN_ONLY_HOST();                 // 0xc51efddd\\n\\n    /**************************************************************************\\n     * Basic information\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Get superfluid host contract address\\n     */\\n    function getHost() external view returns(address host);\\n\\n    /**\\n     * @dev Encoded liquidation type data mainly used for handling stack to deep errors\\n     *\\n     * @custom:note \\n     * - version: 1\\n     * - liquidationType key:\\n     *    - 0 = reward account receives reward (PIC period)\\n     *    - 1 = liquidator account receives reward (Pleb period)\\n     *    - 2 = liquidator account receives reward (Pirate period/bailout)\\n     */\\n    struct LiquidationTypeData {\\n        uint256 version;\\n        uint8 liquidationType;\\n    }\\n\\n    /**************************************************************************\\n     * Real-time balance functions\\n     *************************************************************************/\\n\\n    /**\\n    * @dev Calculate the real balance of a user, taking in consideration all agreements of the account\\n    * @param account for the query\\n    * @param timestamp Time of balance\\n    * @return availableBalance Real-time balance\\n    * @return deposit Account deposit\\n    * @return owedDeposit Account owed Deposit\\n    */\\n    function realtimeBalanceOf(\\n       address account,\\n       uint256 timestamp\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit);\\n\\n    /**\\n     * @notice Calculate the realtime balance given the current host.getNow() value\\n     * @dev realtimeBalanceOf with timestamp equals to block timestamp\\n     * @param account for the query\\n     * @return availableBalance Real-time balance\\n     * @return deposit Account deposit\\n     * @return owedDeposit Account owed Deposit\\n     */\\n    function realtimeBalanceOfNow(\\n       address account\\n    )\\n        external view\\n        returns (\\n            int256 availableBalance,\\n            uint256 deposit,\\n            uint256 owedDeposit,\\n            uint256 timestamp);\\n\\n    /**\\n    * @notice Check if account is critical\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @param timestamp The time we'd like to check if the account is critical (should use future)\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCritical(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n    * @notice Check if account is critical now (current host.getNow())\\n    * @dev A critical account is when availableBalance < 0\\n    * @param account The account to check\\n    * @return isCritical Whether the account is critical\\n    */\\n    function isAccountCriticalNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isCritical);\\n\\n    /**\\n     * @notice Check if account is solvent\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @param timestamp The time we'd like to check if the account is solvent (should use future)\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolvent(\\n        address account,\\n        uint256 timestamp\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n     * @notice Check if account is solvent now\\n     * @dev An account is insolvent when the sum of deposits for a token can't cover the negative availableBalance\\n     * @param account The account to check\\n     * @return isSolvent True if the account is solvent, false otherwise\\n     */\\n    function isAccountSolventNow(\\n        address account\\n    )\\n        external view\\n        returns(bool isSolvent);\\n\\n    /**\\n    * @notice Get a list of agreements that is active for the account\\n    * @dev An active agreement is one that has state for the account\\n    * @param account Account to query\\n    * @return activeAgreements List of accounts that have non-zero states for the account\\n    */\\n    function getAccountActiveAgreements(address account)\\n       external view\\n       returns(ISuperAgreement[] memory activeAgreements);\\n\\n\\n   /**************************************************************************\\n    * Super Agreement hosting functions\\n    *************************************************************************/\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function createAgreement(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement created event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementCreated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Get data of the agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @return data Data of the agreement\\n     */\\n    function getAgreementData(\\n        address agreementClass,\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external view\\n        returns(bytes32[] memory data);\\n\\n    /**\\n     * @dev Create a new agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    function updateAgreementData(\\n        bytes32 id,\\n        bytes32[] calldata data\\n    )\\n        external;\\n    /**\\n     * @dev Agreement updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param data Agreement data\\n     */\\n    event AgreementUpdated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        bytes32[] data\\n    );\\n\\n    /**\\n     * @dev Close the agreement\\n     * @param id Agreement ID\\n     */\\n    function terminateAgreement(\\n        bytes32 id,\\n        uint dataLength\\n    )\\n        external;\\n    /**\\n     * @dev Agreement terminated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     */\\n    event AgreementTerminated(\\n        address indexed agreementClass,\\n        bytes32 id\\n    );\\n\\n    /**\\n     * @dev Update agreement state slot\\n     * @param account Account to be updated\\n     *\\n     * @custom:note \\n     * - To clear the storage out, provide zero-ed array of intended length\\n     */\\n    function updateAgreementStateSlot(\\n        address account,\\n        uint256 slotId,\\n        bytes32[] calldata slotData\\n    )\\n        external;\\n    /**\\n     * @dev Agreement account state updated event\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account updated\\n     * @param slotId slot id of the agreement state\\n     */\\n    event AgreementStateUpdated(\\n        address indexed agreementClass,\\n        address indexed account,\\n        uint256 slotId\\n    );\\n\\n    /**\\n     * @dev Get data of the slot of the state of an agreement\\n     * @param agreementClass Contract address of the agreement\\n     * @param account Account to query\\n     * @param slotId slot id of the state\\n     * @param dataLength length of the state data\\n     */\\n    function getAgreementStateSlot(\\n        address agreementClass,\\n        address account,\\n        uint256 slotId,\\n        uint dataLength\\n    )\\n        external view\\n        returns (bytes32[] memory slotData);\\n\\n    /**\\n     * @notice Settle balance from an account by the agreement\\n     * @dev The agreement needs to make sure that the balance delta is balanced afterwards\\n     * @param account Account to query.\\n     * @param delta Amount of balance delta to be settled\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function settleBalance(\\n        address account,\\n        int256 delta\\n    )\\n        external;\\n\\n    /**\\n     * @dev Make liquidation payouts (v2)\\n     * @param id Agreement ID\\n     * @param liquidationTypeData Data regarding the version of the liquidation schema and the type\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param useDefaultRewardAccount Whether or not the default reward account receives the rewardAmount\\n     * @param targetAccount Account to be liquidated\\n     * @param rewardAmount The amount the rewarded account will receive\\n     * @param targetAccountBalanceDelta The delta amount the target account balance should change by\\n     *\\n     * @custom:note \\n     * - If a bailout is required (bailoutAmount > 0)\\n     *   - the actual reward (single deposit) goes to the executor,\\n     *   - while the reward account becomes the bailout account\\n     *   - total bailout include: bailout amount + reward amount\\n     *   - the targetAccount will be bailed out\\n     * - If a bailout is not required\\n     *   - the targetAccount will pay the rewardAmount\\n     *   - the liquidator (reward account in PIC period) will receive the rewardAmount\\n     *\\n     * @custom:modifiers \\n     *  - onlyAgreement\\n     */\\n    function makeLiquidationPayoutsV2\\n    (\\n        bytes32 id,\\n        bytes memory liquidationTypeData,\\n        address liquidatorAccount,\\n        bool useDefaultRewardAccount,\\n        address targetAccount,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta\\n    ) external;\\n    /**\\n     * @dev Agreement liquidation event v2 (including agent account)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param liquidatorAccount Address of the executor of the liquidation\\n     * @param targetAccount Account of the stream sender\\n     * @param rewardAmountReceiver Account that collects the reward or bails out insolvent accounts\\n     * @param rewardAmount The amount the reward recipient account balance should change by\\n     * @param targetAccountBalanceDelta The amount the sender account balance should change by\\n     * @param liquidationTypeData The encoded liquidation type data including the version (how to decode)\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if the agreement is liquidated during the PIC period\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit), regardless of the liquidatorAccount\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the agreement is liquidated after the PIC period AND the targetAccount is solvent\\n     *   - the rewardAmountReceiver will get the rewardAmount (remaining deposit)\\n     *   - the targetAccount will pay for the rewardAmount\\n     * - if the targetAccount is insolvent\\n     *   - the liquidatorAccount will get the rewardAmount (single deposit)\\n     *   - the default reward account (governance) will pay for both the rewardAmount and bailoutAmount\\n     *   - the targetAccount will receive the bailoutAmount\\n     */\\n    event AgreementLiquidatedV2(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed liquidatorAccount,\\n        address indexed targetAccount,\\n        address rewardAmountReceiver,\\n        uint256 rewardAmount,\\n        int256 targetAccountBalanceDelta,\\n        bytes liquidationTypeData\\n    );\\n\\n    /**************************************************************************\\n     * Function modifiers for access control and parameter validations\\n     *\\n     * While they cannot be explicitly stated in function definitions, they are\\n     * listed in function definition comments instead for clarity.\\n     *\\n     * NOTE: solidity-coverage not supporting it\\n     *************************************************************************/\\n\\n     /// @dev The msg.sender must be host contract\\n     //modifier onlyHost() virtual;\\n\\n    /// @dev The msg.sender must be a listed agreement.\\n    //modifier onlyAgreement() virtual;\\n\\n    /**************************************************************************\\n     * DEPRECATED\\n     *************************************************************************/\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param rewardAccount Account that collect the reward\\n     * @param rewardAmount Amount of liquidation reward\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event AgreementLiquidated(\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed rewardAccount,\\n        uint256 rewardAmount\\n    );\\n\\n    /**\\n     * @dev System bailout occurred (DEPRECATED BY AgreementLiquidatedBy)\\n     * @param bailoutAccount Account that bailout the penalty account\\n     * @param bailoutAmount Amount of account bailout\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     */\\n    event Bailout(\\n        address indexed bailoutAccount,\\n        uint256 bailoutAmount\\n    );\\n\\n    /**\\n     * @dev Agreement liquidation event (DEPRECATED BY AgreementLiquidatedV2)\\n     * @param liquidatorAccount Account of the agent that performed the liquidation.\\n     * @param agreementClass Contract address of the agreement\\n     * @param id Agreement ID\\n     * @param penaltyAccount Account of the agreement to be penalized\\n     * @param bondAccount Account that collect the reward or bailout accounts\\n     * @param rewardAmount Amount of liquidation reward\\n     * @param bailoutAmount Amount of liquidation bailouot\\n     *\\n     * @custom:deprecated Use AgreementLiquidatedV2 instead\\n     *\\n     * @custom:note \\n     * Reward account rule:\\n     * - if bailout is equal to 0, then\\n     *   - the bondAccount will get the rewardAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount.\\n     * - if bailout is larger than 0, then\\n     *   - the liquidatorAccount will get the rewardAmouont,\\n     *   - the bondAccount will pay for both the rewardAmount and bailoutAmount,\\n     *   - the penaltyAccount will pay for the rewardAmount while get the bailoutAmount.\\n     */\\n    event AgreementLiquidatedBy(\\n        address liquidatorAccount,\\n        address indexed agreementClass,\\n        bytes32 id,\\n        address indexed penaltyAccount,\\n        address indexed bondAccount,\\n        uint256 rewardAmount,\\n        uint256 bailoutAmount\\n    );\\n}\\n\",\"keccak256\":\"0x9cad3866982902ea88df0874a563d2e4aeba5a5bcc6289c30cccf9b4099d2fb6\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ERC20WithTokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TokenInfo } from \\\"./TokenInfo.sol\\\";\\n\\n/**\\n * @title ERC20 token with token info interface\\n * @author Superfluid\\n * @dev Using abstract contract instead of interfaces because old solidity\\n *      does not support interface inheriting other interfaces\\n * solhint-disable-next-line no-empty-blocks\\n *\\n */\\n// solhint-disable-next-line no-empty-blocks\\nabstract contract ERC20WithTokenInfo is IERC20, TokenInfo {}\\n\",\"keccak256\":\"0x55be78ffb441c782f612b153d7d9049e3f0dbfd412c1f7df29c896b972b2985f\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity 0.8.16;\\n\\nimport { ISuperToken } from \\\"../superfluid/ISuperToken.sol\\\";\\n\\n\\n/**\\n * @title Super ETH (SETH) custom token interface\\n * @author Superfluid\\n */\\ninterface ISETHCustom {\\n    // using native token\\n    function upgradeByETH() external payable;\\n    function upgradeByETHTo(address to) external payable;\\n    function downgradeToETH(uint wad) external;\\n}\\n\\n/**\\n * @title Super ETH (SETH) full interface\\n * @author Superfluid\\n */\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISETH is ISETHCustom, ISuperToken {}\\n\",\"keccak256\":\"0x29c0452bbbe14fef31477df48bab94e9943a83b7da304da37997705c46a3e00e\",\"license\":\"AGPLv3\"},\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/TokenInfo.sol\":{\"content\":\"// SPDX-License-Identifier: AGPLv3\\npragma solidity >= 0.8.4;\\n\\n/**\\n * @title ERC20 token info interface\\n * @author Superfluid\\n * @dev ERC20 standard interface does not specify these functions, but\\n *      often the token implementations have them.\\n */\\ninterface TokenInfo {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x7456cd394cc905aae7cdbd4601ce1c296c768c13c28e66efbb913cc070bad3e4\",\"license\":\"AGPLv3\"},\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x3f485fb1a44e8fbeadefb5da07d66edab3cfe809f0ac4074b1e54e3eb3c4cf69\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x9bfaf1feb32814623e627ab70f2409760b15d95f1f9b058e2b3399a8bb732975\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n}\\n\",\"keccak256\":\"0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/SuperfluidStream.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport {ISuperfluid} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol\\\";\\r\\nimport {IConstantFlowAgreementV1} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/agreements/IConstantFlowAgreementV1.sol\\\";\\r\\nimport {ISuperToken} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperToken.sol\\\";\\r\\nimport {ISETHCustom} from \\\"@superfluid-finance/ethereum-contracts/contracts/interfaces/tokens/ISETH.sol\\\";\\r\\nimport {CFAv1Library} from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/CFAv1Library.sol\\\";\\r\\nimport {SuperTokenV1Library} from \\\"@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol\\\";\\r\\nimport \\\"hardhat/console.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/AutomationCompatible.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\r\\nimport \\\"@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol\\\";\\r\\n\\r\\nerror SuperfluidStream__NotEnoughSuperToken(\\r\\n    address sender,\\r\\n    uint256 superAmount\\r\\n);\\r\\nerror SuperfluidStream__NoSuperTokenToDowngrade();\\r\\nerror SuperfluidStream__FlowHadBeenCreatedToThisReceiver(\\r\\n    address sender,\\r\\n    uint superAmount\\r\\n);\\r\\nerror SuperfluidStream__FlowToTheReceiverExist();\\r\\n\\r\\ncontract SuperfluidStream is ReentrancyGuard, AutomationCompatibleInterface {\\r\\n    /**Type Variables */\\r\\n    enum SwapState {\\r\\n        OPEN,\\r\\n        PENDING,\\r\\n        CLOSE\\r\\n    }\\r\\n\\r\\n    struct SwappingAddress {\\r\\n        address from;\\r\\n        address to;\\r\\n    }\\r\\n    event UpgradeSuccess(address sender, uint256 upgradeAmount);\\r\\n    event DowngradeSuccess(address sender, uint256 downgradeAmount);\\r\\n    event FlowCreated(address sender, address receiver, int96 flowRatePerMonth);\\r\\n    event FlowDeleted(address sender, address receiver);\\r\\n    event SwapSuccess();\\r\\n\\r\\n    /**State Variable */\\r\\n    using CFAv1Library for CFAv1Library.InitData;\\r\\n    CFAv1Library.InitData public cfaLib;\\r\\n    using SuperTokenV1Library for ISuperToken;\\r\\n\\r\\n    ISuperToken private immutable i_tokenAddress;\\r\\n    ISuperToken private immutable i_fDAIAddress;\\r\\n    ISwapRouter private immutable i_swapRouter;\\r\\n    SwapState private s_swapState;\\r\\n    uint24 public constant POOL_FEE = 3000;\\r\\n    uint256 private immutable i_interval;\\r\\n    uint256 private lastTimeStamp;\\r\\n    uint256 private s_swapperSwapAmount;\\r\\n    address private s_swapFrom;\\r\\n    address private s_swapTo;\\r\\n    uint256 private s_swapTime;\\r\\n    uint256 private s_duration;\\r\\n\\r\\n    mapping(address => mapping(address => int96)) private s_streamCreated;\\r\\n\\r\\n    constructor(\\r\\n        ISuperfluid host,\\r\\n        ISuperToken tokenAddress,\\r\\n        ISwapRouter _swapRouter,\\r\\n        uint256 interval,\\r\\n        ISuperToken fDAIAddress\\r\\n    ) {\\r\\n        i_tokenAddress = tokenAddress;\\r\\n        i_swapRouter = _swapRouter;\\r\\n        i_interval = interval;\\r\\n        s_swapState = SwapState.CLOSE;\\r\\n        i_fDAIAddress = fDAIAddress;\\r\\n\\r\\n        cfaLib = CFAv1Library.InitData(\\r\\n            host,\\r\\n            //here, we are deriving the address of the CFA using the host contract\\r\\n            IConstantFlowAgreementV1(\\r\\n                address(\\r\\n                    host.getAgreementClass(\\r\\n                        keccak256(\\r\\n                            \\\"org.superfluid-finance.agreements.ConstantFlowAgreement.v1\\\"\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    fallback() external payable {}\\r\\n\\r\\n    function checkUpkeep(\\r\\n        bytes memory /* checkData */\\r\\n    )\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (bool upkeepNeeded, bytes memory /* performData */)\\r\\n    {\\r\\n        bool isSwapOpen = (SwapState.OPEN == s_swapState);\\r\\n        bool isSwapPending = (SwapState.PENDING == s_swapState);\\r\\n        bool timePassed = (block.timestamp - lastTimeStamp) >= i_interval;\\r\\n        upkeepNeeded = (isSwapOpen || isSwapPending) && timePassed;\\r\\n    }\\r\\n\\r\\n    //TODO:link swapstate to each msg.sender to allow multiple entry at one time\\r\\n    //TODO:amend block.timestamp so that lastTimeStamp will be taken during \\\"swap\\\" not \\\"enterSwap\\\"\\r\\n    function enterSwap() external {\\r\\n        s_swapState = SwapState.OPEN;\\r\\n        lastTimeStamp = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function performUpkeep(bytes calldata /* performData */) external override {\\r\\n        (bool upkeepNeeded, ) = checkUpkeep(\\\"\\\");\\r\\n        s_swapTime += 1;\\r\\n        if (s_swapTime < s_duration) {\\r\\n            if (upkeepNeeded) {\\r\\n                swap(s_swapperSwapAmount, s_swapFrom, s_swapTo, s_duration);\\r\\n                lastTimeStamp = block.timestamp;\\r\\n            }\\r\\n            s_swapState = SwapState.PENDING;\\r\\n        }\\r\\n        if (s_swapTime == s_duration) {\\r\\n            s_swapState = SwapState.CLOSE;\\r\\n            s_swapTime = 0;\\r\\n            emit SwapSuccess();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swap(\\r\\n        uint256 amountIn,\\r\\n        address tokenIn,\\r\\n        address tokenOut,\\r\\n        uint256 duration\\r\\n    ) public returns (uint256 amountOut) {\\r\\n        s_swapperSwapAmount = amountIn;\\r\\n        s_swapFrom = tokenIn;\\r\\n        s_swapTo = tokenOut;\\r\\n        s_duration = duration;\\r\\n        TransferHelper.safeApprove(tokenIn, address(i_swapRouter), amountIn);\\r\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\r\\n            .ExactInputSingleParams({\\r\\n                tokenIn: tokenIn,\\r\\n                tokenOut: tokenOut,\\r\\n                fee: POOL_FEE,\\r\\n                recipient: address(this),\\r\\n                deadline: block.timestamp, //make sure the swap wont go on forever as the price of token might shift\\r\\n                amountIn: amountIn,\\r\\n                amountOutMinimum: 0,\\r\\n                sqrtPriceLimitX96: 0\\r\\n            });\\r\\n        amountOut = i_swapRouter.exactInputSingle(params);\\r\\n    }\\r\\n\\r\\n    function upgradeMATIC() external payable nonReentrant {\\r\\n        if (msg.value <= 0) {\\r\\n            revert SuperfluidStream__NotEnoughSuperToken(msg.sender, msg.value);\\r\\n        }\\r\\n\\r\\n        ISETHCustom(address(i_tokenAddress)).upgradeByETHTo{value: msg.value}(\\r\\n            address(this)\\r\\n        );\\r\\n        emit UpgradeSuccess(msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    function downgradeMATICx(uint256 wad) external {\\r\\n        ISETHCustom(address(i_tokenAddress)).downgradeToETH(wad); //this will transfer MATIC back to smart contract address\\r\\n        payable(msg.sender).transfer(wad); //this is to transfer the MATIC back to sender's account\\r\\n        emit DowngradeSuccess(msg.sender, wad);\\r\\n    }\\r\\n\\r\\n    function createFlow(address receiver, int96 flowRatePerMonth) external {\\r\\n        if (s_streamCreated[msg.sender][receiver] > 0) {\\r\\n            revert SuperfluidStream__FlowToTheReceiverExist();\\r\\n        }\\r\\n        s_streamCreated[msg.sender][receiver] = flowRatePerMonth;\\r\\n        int96 flowRatePerSecond = (flowRatePerMonth / 3600 / 24 / 30);\\r\\n        i_tokenAddress.createFlow(receiver, flowRatePerSecond);\\r\\n        emit FlowCreated(msg.sender, receiver, flowRatePerMonth);\\r\\n    }\\r\\n\\r\\n    function updateFlow(address receiver, int96 flowRatePerMonth) external {\\r\\n        s_streamCreated[msg.sender][receiver] = flowRatePerMonth;\\r\\n        int96 flowRatePerSecond = (flowRatePerMonth / 3600 / 24 / 30);\\r\\n        i_tokenAddress.updateFlow(receiver, flowRatePerSecond);\\r\\n        emit FlowCreated(msg.sender, receiver, flowRatePerMonth);\\r\\n    }\\r\\n\\r\\n    function deleteFlow(address receiver) external {\\r\\n        delete (s_streamCreated[msg.sender][receiver]);\\r\\n        i_tokenAddress.deleteFlow(address(this), receiver);\\r\\n        emit FlowDeleted(msg.sender, receiver);\\r\\n    }\\r\\n\\r\\n    function withdrawfDAI(uint256 fDAIAmountOut) external {\\r\\n        ISuperToken(i_fDAIAddress).transfer(msg.sender, fDAIAmountOut);\\r\\n    }\\r\\n\\r\\n    function getMATICxBalance(address receiver) public view returns (uint256) {\\r\\n        return ISuperToken(i_tokenAddress).balanceOf(receiver);\\r\\n    }\\r\\n\\r\\n    function getSwapState() public view returns (SwapState) {\\r\\n        return s_swapState;\\r\\n    }\\r\\n\\r\\n    function getInterval() public view returns (uint256) {\\r\\n        return i_interval;\\r\\n    }\\r\\n\\r\\n    function getLastTimeStamp() public view returns (uint256) {\\r\\n        return lastTimeStamp;\\r\\n    }\\r\\n\\r\\n    function getSwapperSwapAmount() public view returns (uint256) {\\r\\n        return s_swapperSwapAmount;\\r\\n    }\\r\\n\\r\\n    function getSwapFrom() public view returns (address) {\\r\\n        return s_swapFrom;\\r\\n    }\\r\\n\\r\\n    function getSwapTo() public view returns (address) {\\r\\n        return s_swapTo;\\r\\n    }\\r\\n\\r\\n    function getSwapTime() public view returns (uint256) {\\r\\n        return s_swapTime;\\r\\n    }\\r\\n\\r\\n    function getDuration() public view returns (uint256) {\\r\\n        return s_duration;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x35dcad67dcb8c9219a46bf73d59470c093b7efa94c2f450e05926782eaa9504b\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101006040523480156200001257600080fd5b5060405162002f9b38038062002f9b8339818101604052810190620000389190620003d2565b60016000819055508373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508273ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250508160e081815250506002600360006101000a81548160ff02191690836002811115620000d957620000d86200045a565b5b02179055508073ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff168152505060405180604001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018673ffffffffffffffffffffffffffffffffffffffff1663b6d200de7fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd36040518263ffffffff1660e01b8152600401620001949190620004a4565b602060405180830381865afa158015620001b2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001d8919062000506565b73ffffffffffffffffffffffffffffffffffffffff16815250600160008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550905050505050505062000538565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000620002c18262000294565b9050919050565b6000620002d582620002b4565b9050919050565b620002e781620002c8565b8114620002f357600080fd5b50565b6000815190506200030781620002dc565b92915050565b60006200031a82620002b4565b9050919050565b6200032c816200030d565b81146200033857600080fd5b50565b6000815190506200034c8162000321565b92915050565b60006200035f82620002b4565b9050919050565b620003718162000352565b81146200037d57600080fd5b50565b600081519050620003918162000366565b92915050565b6000819050919050565b620003ac8162000397565b8114620003b857600080fd5b50565b600081519050620003cc81620003a1565b92915050565b600080600080600060a08688031215620003f157620003f06200028f565b5b60006200040188828901620002f6565b955050602062000414888289016200033b565b9450506040620004278882890162000380565b93505060606200043a88828901620003bb565b92505060806200044d888289016200033b565b9150509295509295909350565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b6000819050919050565b6200049e8162000489565b82525050565b6000602082019050620004bb600083018462000493565b92915050565b6000620004ce82620002b4565b9050919050565b620004e081620004c1565b8114620004ec57600080fd5b50565b6000815190506200050081620004d5565b92915050565b6000602082840312156200051f576200051e6200028f565b5b60006200052f84828501620004ef565b91505092915050565b60805160a05160c05160e0516129f8620005a3600039600081816107b20152610ccc015260008181610897015261095d01526000610e1a01526000818161069501528181610a2e01528181610c4301528181610d4101528181611060015261119301526129f86000f3fe60806040526004361061012e5760003560e01c80638568f0ec116100ab578063b4130f2d1161006f578063b4130f2d146103b9578063bf8d075b146103e2578063c1c244e81461040b578063dd1b9c4a14610436578063f53d93c714610461578063f5e380071461048a57610135565b80638568f0ec146103055780638bf08bb61461033057806391ad27b414610359578063986935ec14610384578063ad2e8c9b1461038e57610135565b806361ba4fb8116100f257806361ba4fb8146101f95780636e04ff0d1461023657806370085be01461027457806373d5f726146102b157806374faa28b146102dc57610135565b80630977482e14610137578063249d6dc714610163578063333003761461018e5780634585e33b146101a557806355c32b4e146101ce57610135565b3661013557005b005b34801561014357600080fd5b5061014c6104b5565b60405161015a929190611c19565b60405180910390f35b34801561016f57600080fd5b50610178610507565b6040516101859190611c5b565b60405180910390f35b34801561019a57600080fd5b506101a3610511565b005b3480156101b157600080fd5b506101cc60048036038101906101c79190611cef565b610545565b005b3480156101da57600080fd5b506101e3610687565b6040516101f09190611c5b565b60405180910390f35b34801561020557600080fd5b50610220600480360381019061021b9190611d7a565b610691565b60405161022d9190611c5b565b60405180910390f35b34801561024257600080fd5b5061025d60048036038101906102589190611ee8565b610734565b60405161026b929190611fcb565b60405180910390f35b34801561028057600080fd5b5061029b60048036038101906102969190612027565b6107ff565b6040516102a89190611c5b565b60405180910390f35b3480156102bd57600080fd5b506102c6610a02565b6040516102d3919061209d565b60405180910390f35b3480156102e857600080fd5b5061030360048036038101906102fe91906120b8565b610a2c565b005b34801561031157600080fd5b5061031a610b3a565b604051610327919061209d565b60405180910390f35b34801561033c57600080fd5b506103576004803603810190610352919061211e565b610b64565b005b34801561036557600080fd5b5061036e610cc8565b60405161037b9190611c5b565b60405180910390f35b61038c610cf0565b005b34801561039a57600080fd5b506103a3610e0e565b6040516103b09190611c5b565b60405180910390f35b3480156103c557600080fd5b506103e060048036038101906103db91906120b8565b610e18565b005b3480156103ee57600080fd5b506104096004803603810190610404919061211e565b610eba565b005b34801561041757600080fd5b506104206110e5565b60405161042d9190611c5b565b60405180910390f35b34801561044257600080fd5b5061044b6110ef565b604051610458919061217c565b60405180910390f35b34801561046d57600080fd5b5061048860048036038101906104839190611d7a565b6110f5565b005b34801561049657600080fd5b5061049f611214565b6040516104ac919061220e565b60405180910390f35b60018060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082565b6000600854905090565b6000600360006101000a81548160ff0219169083600281111561053757610536612197565b5b021790555042600481905550565b600061055f60405180602001604052806000815250610734565b5090506001600860008282546105759190612258565b9250508190555060095460085410156106175780156105eb576105e2600554600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166009546107ff565b50426004819055505b6001600360006101000a81548160ff0219169083600281111561061157610610612197565b5b02179055505b60095460085403610682576002600360006101000a81548160ff0219169083600281111561064857610647612197565b5b021790555060006008819055507f83ae5d684d4bb83a2df3011813d52adafdf58ac5223cc62c5bb8a773e95328b660405160405180910390a15b505050565b6000600554905090565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b81526004016106ec919061209d565b602060405180830381865afa158015610709573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072d91906122a1565b9050919050565b600060606000600360009054906101000a900460ff16600281111561075c5761075b612197565b5b600060028111156107705761076f612197565b5b1490506000600360009054906101000a900460ff16600281111561079757610796612197565b5b600160028111156107ab576107aa612197565b5b14905060007f0000000000000000000000000000000000000000000000000000000000000000600454426107df91906122ce565b1015905082806107ec5750815b80156107f55750805b9450505050915091565b60008460058190555083600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550816009819055506108bc847f00000000000000000000000000000000000000000000000000000000000000008761122b565b60006040518061010001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff168152602001610bb862ffffff1681526020013073ffffffffffffffffffffffffffffffffffffffff16815260200142815260200187815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681525090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663414bf389826040518263ffffffff1660e01b81526004016109b491906123e0565b6020604051808303816000875af11580156109d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f791906122a1565b915050949350505050565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663160e8be3826040518263ffffffff1660e01b8152600401610a859190611c5b565b600060405180830381600087803b158015610a9f57600080fd5b505af1158015610ab3573d6000803e3d6000fd5b505050503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610afd573d6000803e3d6000fd5b507fa164678d0bda664fd1c7e4a07f1e5522d81bc7ab4948de1c5e6065cab7da34903382604051610b2f9291906123fc565b60405180910390a150565b6000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b80600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a8154816bffffffffffffffffffffffff0219169083600b0b6bffffffffffffffffffffffff1602179055506000601e6018610e1084610c269190612454565b610c309190612454565b610c3a9190612454565b9050610c8783827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166113809092919063ffffffff16565b507f69a172371a3ea3c3b6c825bff6fa836c7c5fe25c7df3feedc847d360b010d45a338484604051610cbb939291906124cd565b60405180910390a1505050565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b610cf8611533565b60003411610d3f5733346040517f16ef74ca000000000000000000000000000000000000000000000000000000008152600401610d369291906123fc565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637687d19b34306040518363ffffffff1660e01b8152600401610d99919061209d565b6000604051808303818588803b158015610db257600080fd5b505af1158015610dc6573d6000803e3d6000fd5b50505050507fe662f9a037203bb6dc51961c72a83db0a070124d371c582e38e1607ec32e45523334604051610dfc9291906123fc565b60405180910390a1610e0c611582565b565b6000600954905090565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610e739291906123fc565b6020604051808303816000875af1158015610e92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb69190612530565b5050565b6000600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a9004600b0b600b0b1315610f81576040517fd49d89c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a8154816bffffffffffffffffffffffff0219169083600b0b6bffffffffffffffffffffffff1602179055506000601e6018610e10846110439190612454565b61104d9190612454565b6110579190612454565b90506110a483827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661158c9092919063ffffffff16565b507f69a172371a3ea3c3b6c825bff6fa836c7c5fe25c7df3feedc847d360b010d45a3384846040516110d8939291906124cd565b60405180910390a1505050565b6000600454905090565b610bb881565b600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a8154906bffffffffffffffffffffffff02191690556111d730827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661173f9092919063ffffffff16565b507f64d675fb197e6c07a8c9890564138535ad877ce2a89cce0d2786490b52ce2801338260405161120992919061255d565b60405180910390a150565b6000600360009054906101000a900460ff16905090565b6000808473ffffffffffffffffffffffffffffffffffffffff1663095ea7b360e01b85856040516024016112609291906123fc565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040516112ca91906125c2565b6000604051808303816000865af19150503d8060008114611307576040519150601f19603f3d011682016040523d82523d6000602084013e61130c565b606091505b509150915081801561133a57506000815114806113395750808060200190518101906113389190612530565b5b5b611379576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161137090612636565b60405180910390fd5b5050505050565b600080600061138e866118f2565b915091508173ffffffffffffffffffffffffffffffffffffffff166339255d5b828373ffffffffffffffffffffffffffffffffffffffff166350209a628a8a8a600067ffffffffffffffff8111156113e9576113e8611dbd565b5b6040519080825280601f01601f19166020018201604052801561141b5781602001600182028036833780820191505090505b5060405160240161142f9493929190612677565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050600067ffffffffffffffff81111561148c5761148b611dbd565b5b6040519080825280601f01601f1916602001820160405280156114be5781602001600182028036833780820191505090505b506040518463ffffffff1660e01b81526004016114dd939291906126c3565b6000604051808303816000875af11580156114fc573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906115259190612778565b506001925050509392505050565b600260005403611578576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156f9061280d565b60405180910390fd5b6002600081905550565b6001600081905550565b600080600061159a866118f2565b915091508173ffffffffffffffffffffffffffffffffffffffff166339255d5b828373ffffffffffffffffffffffffffffffffffffffff166362fc305e8a8a8a600067ffffffffffffffff8111156115f5576115f4611dbd565b5b6040519080825280601f01601f1916602001820160405280156116275781602001600182028036833780820191505090505b5060405160240161163b9493929190612677565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050600067ffffffffffffffff81111561169857611697611dbd565b5b6040519080825280601f01601f1916602001820160405280156116ca5781602001600182028036833780820191505090505b506040518463ffffffff1660e01b81526004016116e9939291906126c3565b6000604051808303816000875af1158015611708573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906117319190612778565b506001925050509392505050565b600080600061174d866118f2565b915091508173ffffffffffffffffffffffffffffffffffffffff166339255d5b828373ffffffffffffffffffffffffffffffffffffffff1663b4b333c68a8a8a600067ffffffffffffffff8111156117a8576117a7611dbd565b5b6040519080825280601f01601f1916602001820160405280156117da5781602001600182028036833780820191505090505b506040516024016117ee949392919061282d565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050600067ffffffffffffffff81111561184b5761184a611dbd565b5b6040519080825280601f01601f19166020018201604052801561187d5781602001600182028036833780820191505090505b506040518463ffffffff1660e01b815260040161189c939291906126c3565b6000604051808303816000875af11580156118bb573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906118e49190612778565b506001925050509392505050565b6000807f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea8375491507fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a549050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611afa57600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603611a17578273ffffffffffffffffffffffffffffffffffffffff166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119f0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a14919061288e565b91505b8173ffffffffffffffffffffffffffffffffffffffff1663b6d200de7fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd36040518263ffffffff1660e01b8152600401611a70919061290d565b602060405180830381865afa158015611a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ab19190612966565b9050817f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea83755807fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a555b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603611b3757611b36612993565b5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611b7457611b73612993565b5b915091565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b6000611bbe611bb9611bb484611b79565b611b99565b611b79565b9050919050565b6000611bd082611ba3565b9050919050565b6000611be282611bc5565b9050919050565b611bf281611bd7565b82525050565b6000611c0382611bc5565b9050919050565b611c1381611bf8565b82525050565b6000604082019050611c2e6000830185611be9565b611c3b6020830184611c0a565b9392505050565b6000819050919050565b611c5581611c42565b82525050565b6000602082019050611c706000830184611c4c565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f840112611caf57611cae611c8a565b5b8235905067ffffffffffffffff811115611ccc57611ccb611c8f565b5b602083019150836001820283011115611ce857611ce7611c94565b5b9250929050565b60008060208385031215611d0657611d05611c80565b5b600083013567ffffffffffffffff811115611d2457611d23611c85565b5b611d3085828601611c99565b92509250509250929050565b6000611d4782611b79565b9050919050565b611d5781611d3c565b8114611d6257600080fd5b50565b600081359050611d7481611d4e565b92915050565b600060208284031215611d9057611d8f611c80565b5b6000611d9e84828501611d65565b91505092915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611df582611dac565b810181811067ffffffffffffffff82111715611e1457611e13611dbd565b5b80604052505050565b6000611e27611c76565b9050611e338282611dec565b919050565b600067ffffffffffffffff821115611e5357611e52611dbd565b5b611e5c82611dac565b9050602081019050919050565b82818337600083830152505050565b6000611e8b611e8684611e38565b611e1d565b905082815260208101848484011115611ea757611ea6611da7565b5b611eb2848285611e69565b509392505050565b600082601f830112611ecf57611ece611c8a565b5b8135611edf848260208601611e78565b91505092915050565b600060208284031215611efe57611efd611c80565b5b600082013567ffffffffffffffff811115611f1c57611f1b611c85565b5b611f2884828501611eba565b91505092915050565b60008115159050919050565b611f4681611f31565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611f86578082015181840152602081019050611f6b565b60008484015250505050565b6000611f9d82611f4c565b611fa78185611f57565b9350611fb7818560208601611f68565b611fc081611dac565b840191505092915050565b6000604082019050611fe06000830185611f3d565b8181036020830152611ff28184611f92565b90509392505050565b61200481611c42565b811461200f57600080fd5b50565b60008135905061202181611ffb565b92915050565b6000806000806080858703121561204157612040611c80565b5b600061204f87828801612012565b945050602061206087828801611d65565b935050604061207187828801611d65565b925050606061208287828801612012565b91505092959194509250565b61209781611d3c565b82525050565b60006020820190506120b2600083018461208e565b92915050565b6000602082840312156120ce576120cd611c80565b5b60006120dc84828501612012565b91505092915050565b600081600b0b9050919050565b6120fb816120e5565b811461210657600080fd5b50565b600081359050612118816120f2565b92915050565b6000806040838503121561213557612134611c80565b5b600061214385828601611d65565b925050602061215485828601612109565b9150509250929050565b600062ffffff82169050919050565b6121768161215e565b82525050565b6000602082019050612191600083018461216d565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600381106121d7576121d6612197565b5b50565b60008190506121e8826121c6565b919050565b60006121f8826121da565b9050919050565b612208816121ed565b82525050565b600060208201905061222360008301846121ff565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061226382611c42565b915061226e83611c42565b925082820190508082111561228657612285612229565b5b92915050565b60008151905061229b81611ffb565b92915050565b6000602082840312156122b7576122b6611c80565b5b60006122c58482850161228c565b91505092915050565b60006122d982611c42565b91506122e483611c42565b92508282039050818111156122fc576122fb612229565b5b92915050565b61230b81611d3c565b82525050565b61231a8161215e565b82525050565b61232981611c42565b82525050565b61233881611b79565b82525050565b610100820160008201516123556000850182612302565b5060208201516123686020850182612302565b50604082015161237b6040850182612311565b50606082015161238e6060850182612302565b5060808201516123a16080850182612320565b5060a08201516123b460a0850182612320565b5060c08201516123c760c0850182612320565b5060e08201516123da60e085018261232f565b50505050565b6000610100820190506123f6600083018461233e565b92915050565b6000604082019050612411600083018561208e565b61241e6020830184611c4c565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061245f826120e5565b915061246a836120e5565b92508261247a57612479612425565b5b600160000383147fffffffffffffffffffffffffffffffffffffffff800000000000000000000000831416156124b3576124b2612229565b5b828205905092915050565b6124c7816120e5565b82525050565b60006060820190506124e2600083018661208e565b6124ef602083018561208e565b6124fc60408301846124be565b949350505050565b61250d81611f31565b811461251857600080fd5b50565b60008151905061252a81612504565b92915050565b60006020828403121561254657612545611c80565b5b60006125548482850161251b565b91505092915050565b6000604082019050612572600083018561208e565b61257f602083018461208e565b9392505050565b600081905092915050565b600061259c82611f4c565b6125a68185612586565b93506125b6818560208601611f68565b80840191505092915050565b60006125ce8284612591565b915081905092915050565b600082825260208201905092915050565b7f5341000000000000000000000000000000000000000000000000000000000000600082015250565b60006126206002836125d9565b915061262b826125ea565b602082019050919050565b6000602082019050818103600083015261264f81612613565b9050919050565b600061266182611bc5565b9050919050565b61267181612656565b82525050565b600060808201905061268c6000830187612668565b612699602083018661208e565b6126a660408301856124be565b81810360608301526126b88184611f92565b905095945050505050565b60006060820190506126d86000830186611c0a565b81810360208301526126ea8185611f92565b905081810360408301526126fe8184611f92565b9050949350505050565b600061271b61271684611e38565b611e1d565b90508281526020810184848401111561273757612736611da7565b5b612742848285611f68565b509392505050565b600082601f83011261275f5761275e611c8a565b5b815161276f848260208601612708565b91505092915050565b60006020828403121561278e5761278d611c80565b5b600082015167ffffffffffffffff8111156127ac576127ab611c85565b5b6127b88482850161274a565b91505092915050565b7f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00600082015250565b60006127f7601f836125d9565b9150612802826127c1565b602082019050919050565b60006020820190508181036000830152612826816127ea565b9050919050565b60006080820190506128426000830187612668565b61284f602083018661208e565b61285c604083018561208e565b818103606083015261286e8184611f92565b905095945050505050565b60008151905061288881611d4e565b92915050565b6000602082840312156128a4576128a3611c80565b5b60006128b284828501612879565b91505092915050565b6000819050919050565b6000819050919050565b60008160001b9050919050565b60006128f76128f26128ed846128bb565b6128cf565b6128c5565b9050919050565b612907816128dc565b82525050565b600060208201905061292260008301846128fe565b92915050565b600061293382611d3c565b9050919050565b61294381612928565b811461294e57600080fd5b50565b6000815190506129608161293a565b92915050565b60006020828403121561297c5761297b611c80565b5b600061298a84828501612951565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fdfea264697066735822122024cb6145830ca8621f9d328261efcb50568d2e47d0c9aefd1743371b8d5747b764736f6c63430008100033",
  "deployedBytecode": "0x60806040526004361061012e5760003560e01c80638568f0ec116100ab578063b4130f2d1161006f578063b4130f2d146103b9578063bf8d075b146103e2578063c1c244e81461040b578063dd1b9c4a14610436578063f53d93c714610461578063f5e380071461048a57610135565b80638568f0ec146103055780638bf08bb61461033057806391ad27b414610359578063986935ec14610384578063ad2e8c9b1461038e57610135565b806361ba4fb8116100f257806361ba4fb8146101f95780636e04ff0d1461023657806370085be01461027457806373d5f726146102b157806374faa28b146102dc57610135565b80630977482e14610137578063249d6dc714610163578063333003761461018e5780634585e33b146101a557806355c32b4e146101ce57610135565b3661013557005b005b34801561014357600080fd5b5061014c6104b5565b60405161015a929190611c19565b60405180910390f35b34801561016f57600080fd5b50610178610507565b6040516101859190611c5b565b60405180910390f35b34801561019a57600080fd5b506101a3610511565b005b3480156101b157600080fd5b506101cc60048036038101906101c79190611cef565b610545565b005b3480156101da57600080fd5b506101e3610687565b6040516101f09190611c5b565b60405180910390f35b34801561020557600080fd5b50610220600480360381019061021b9190611d7a565b610691565b60405161022d9190611c5b565b60405180910390f35b34801561024257600080fd5b5061025d60048036038101906102589190611ee8565b610734565b60405161026b929190611fcb565b60405180910390f35b34801561028057600080fd5b5061029b60048036038101906102969190612027565b6107ff565b6040516102a89190611c5b565b60405180910390f35b3480156102bd57600080fd5b506102c6610a02565b6040516102d3919061209d565b60405180910390f35b3480156102e857600080fd5b5061030360048036038101906102fe91906120b8565b610a2c565b005b34801561031157600080fd5b5061031a610b3a565b604051610327919061209d565b60405180910390f35b34801561033c57600080fd5b506103576004803603810190610352919061211e565b610b64565b005b34801561036557600080fd5b5061036e610cc8565b60405161037b9190611c5b565b60405180910390f35b61038c610cf0565b005b34801561039a57600080fd5b506103a3610e0e565b6040516103b09190611c5b565b60405180910390f35b3480156103c557600080fd5b506103e060048036038101906103db91906120b8565b610e18565b005b3480156103ee57600080fd5b506104096004803603810190610404919061211e565b610eba565b005b34801561041757600080fd5b506104206110e5565b60405161042d9190611c5b565b60405180910390f35b34801561044257600080fd5b5061044b6110ef565b604051610458919061217c565b60405180910390f35b34801561046d57600080fd5b5061048860048036038101906104839190611d7a565b6110f5565b005b34801561049657600080fd5b5061049f611214565b6040516104ac919061220e565b60405180910390f35b60018060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16908060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082565b6000600854905090565b6000600360006101000a81548160ff0219169083600281111561053757610536612197565b5b021790555042600481905550565b600061055f60405180602001604052806000815250610734565b5090506001600860008282546105759190612258565b9250508190555060095460085410156106175780156105eb576105e2600554600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff166009546107ff565b50426004819055505b6001600360006101000a81548160ff0219169083600281111561061157610610612197565b5b02179055505b60095460085403610682576002600360006101000a81548160ff0219169083600281111561064857610647612197565b5b021790555060006008819055507f83ae5d684d4bb83a2df3011813d52adafdf58ac5223cc62c5bb8a773e95328b660405160405180910390a15b505050565b6000600554905090565b60007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166370a08231836040518263ffffffff1660e01b81526004016106ec919061209d565b602060405180830381865afa158015610709573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072d91906122a1565b9050919050565b600060606000600360009054906101000a900460ff16600281111561075c5761075b612197565b5b600060028111156107705761076f612197565b5b1490506000600360009054906101000a900460ff16600281111561079757610796612197565b5b600160028111156107ab576107aa612197565b5b14905060007f0000000000000000000000000000000000000000000000000000000000000000600454426107df91906122ce565b1015905082806107ec5750815b80156107f55750805b9450505050915091565b60008460058190555083600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555082600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550816009819055506108bc847f00000000000000000000000000000000000000000000000000000000000000008761122b565b60006040518061010001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff168152602001610bb862ffffff1681526020013073ffffffffffffffffffffffffffffffffffffffff16815260200142815260200187815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681525090507f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663414bf389826040518263ffffffff1660e01b81526004016109b491906123e0565b6020604051808303816000875af11580156109d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109f791906122a1565b915050949350505050565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663160e8be3826040518263ffffffff1660e01b8152600401610a859190611c5b565b600060405180830381600087803b158015610a9f57600080fd5b505af1158015610ab3573d6000803e3d6000fd5b505050503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015610afd573d6000803e3d6000fd5b507fa164678d0bda664fd1c7e4a07f1e5522d81bc7ab4948de1c5e6065cab7da34903382604051610b2f9291906123fc565b60405180910390a150565b6000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b80600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a8154816bffffffffffffffffffffffff0219169083600b0b6bffffffffffffffffffffffff1602179055506000601e6018610e1084610c269190612454565b610c309190612454565b610c3a9190612454565b9050610c8783827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166113809092919063ffffffff16565b507f69a172371a3ea3c3b6c825bff6fa836c7c5fe25c7df3feedc847d360b010d45a338484604051610cbb939291906124cd565b60405180910390a1505050565b60007f0000000000000000000000000000000000000000000000000000000000000000905090565b610cf8611533565b60003411610d3f5733346040517f16ef74ca000000000000000000000000000000000000000000000000000000008152600401610d369291906123fc565b60405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16637687d19b34306040518363ffffffff1660e01b8152600401610d99919061209d565b6000604051808303818588803b158015610db257600080fd5b505af1158015610dc6573d6000803e3d6000fd5b50505050507fe662f9a037203bb6dc51961c72a83db0a070124d371c582e38e1607ec32e45523334604051610dfc9291906123fc565b60405180910390a1610e0c611582565b565b6000600954905090565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb33836040518363ffffffff1660e01b8152600401610e739291906123fc565b6020604051808303816000875af1158015610e92573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb69190612530565b5050565b6000600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a9004600b0b600b0b1315610f81576040517fd49d89c700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a8154816bffffffffffffffffffffffff0219169083600b0b6bffffffffffffffffffffffff1602179055506000601e6018610e10846110439190612454565b61104d9190612454565b6110579190612454565b90506110a483827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661158c9092919063ffffffff16565b507f69a172371a3ea3c3b6c825bff6fa836c7c5fe25c7df3feedc847d360b010d45a3384846040516110d8939291906124cd565b60405180910390a1505050565b6000600454905090565b610bb881565b600a60003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a8154906bffffffffffffffffffffffff02191690556111d730827f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1661173f9092919063ffffffff16565b507f64d675fb197e6c07a8c9890564138535ad877ce2a89cce0d2786490b52ce2801338260405161120992919061255d565b60405180910390a150565b6000600360009054906101000a900460ff16905090565b6000808473ffffffffffffffffffffffffffffffffffffffff1663095ea7b360e01b85856040516024016112609291906123fc565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040516112ca91906125c2565b6000604051808303816000865af19150503d8060008114611307576040519150601f19603f3d011682016040523d82523d6000602084013e61130c565b606091505b509150915081801561133a57506000815114806113395750808060200190518101906113389190612530565b5b5b611379576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161137090612636565b60405180910390fd5b5050505050565b600080600061138e866118f2565b915091508173ffffffffffffffffffffffffffffffffffffffff166339255d5b828373ffffffffffffffffffffffffffffffffffffffff166350209a628a8a8a600067ffffffffffffffff8111156113e9576113e8611dbd565b5b6040519080825280601f01601f19166020018201604052801561141b5781602001600182028036833780820191505090505b5060405160240161142f9493929190612677565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050600067ffffffffffffffff81111561148c5761148b611dbd565b5b6040519080825280601f01601f1916602001820160405280156114be5781602001600182028036833780820191505090505b506040518463ffffffff1660e01b81526004016114dd939291906126c3565b6000604051808303816000875af11580156114fc573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906115259190612778565b506001925050509392505050565b600260005403611578576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161156f9061280d565b60405180910390fd5b6002600081905550565b6001600081905550565b600080600061159a866118f2565b915091508173ffffffffffffffffffffffffffffffffffffffff166339255d5b828373ffffffffffffffffffffffffffffffffffffffff166362fc305e8a8a8a600067ffffffffffffffff8111156115f5576115f4611dbd565b5b6040519080825280601f01601f1916602001820160405280156116275781602001600182028036833780820191505090505b5060405160240161163b9493929190612677565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050600067ffffffffffffffff81111561169857611697611dbd565b5b6040519080825280601f01601f1916602001820160405280156116ca5781602001600182028036833780820191505090505b506040518463ffffffff1660e01b81526004016116e9939291906126c3565b6000604051808303816000875af1158015611708573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906117319190612778565b506001925050509392505050565b600080600061174d866118f2565b915091508173ffffffffffffffffffffffffffffffffffffffff166339255d5b828373ffffffffffffffffffffffffffffffffffffffff1663b4b333c68a8a8a600067ffffffffffffffff8111156117a8576117a7611dbd565b5b6040519080825280601f01601f1916602001820160405280156117da5781602001600182028036833780820191505090505b506040516024016117ee949392919061282d565b604051602081830303815290604052915060e01b6020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff8381831617835250505050600067ffffffffffffffff81111561184b5761184a611dbd565b5b6040519080825280601f01601f19166020018201604052801561187d5781602001600182028036833780820191505090505b506040518463ffffffff1660e01b815260040161189c939291906126c3565b6000604051808303816000875af11580156118bb573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906118e49190612778565b506001925050509392505050565b6000807f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea8375491507fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a549050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611afa57600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603611a17578273ffffffffffffffffffffffffffffffffffffffff166320bc44256040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119f0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a14919061288e565b91505b8173ffffffffffffffffffffffffffffffffffffffff1663b6d200de7fa9214cc96615e0085d3bb077758db69497dc2dce3b2b1e97bc93c3d18d83efd36040518263ffffffff1660e01b8152600401611a70919061290d565b602060405180830381865afa158015611a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ab19190612966565b9050817f65599bf746e17a00ea62e3610586992d88101b78eec3cf380706621fb97ea83755807fb969d79d88acd02d04ed7ee7d43b949e7daf093d363abcfbbc43dfdfd1ce969a555b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1603611b3757611b36612993565b5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603611b7457611b73612993565b5b915091565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b6000611bbe611bb9611bb484611b79565b611b99565b611b79565b9050919050565b6000611bd082611ba3565b9050919050565b6000611be282611bc5565b9050919050565b611bf281611bd7565b82525050565b6000611c0382611bc5565b9050919050565b611c1381611bf8565b82525050565b6000604082019050611c2e6000830185611be9565b611c3b6020830184611c0a565b9392505050565b6000819050919050565b611c5581611c42565b82525050565b6000602082019050611c706000830184611c4c565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f840112611caf57611cae611c8a565b5b8235905067ffffffffffffffff811115611ccc57611ccb611c8f565b5b602083019150836001820283011115611ce857611ce7611c94565b5b9250929050565b60008060208385031215611d0657611d05611c80565b5b600083013567ffffffffffffffff811115611d2457611d23611c85565b5b611d3085828601611c99565b92509250509250929050565b6000611d4782611b79565b9050919050565b611d5781611d3c565b8114611d6257600080fd5b50565b600081359050611d7481611d4e565b92915050565b600060208284031215611d9057611d8f611c80565b5b6000611d9e84828501611d65565b91505092915050565b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611df582611dac565b810181811067ffffffffffffffff82111715611e1457611e13611dbd565b5b80604052505050565b6000611e27611c76565b9050611e338282611dec565b919050565b600067ffffffffffffffff821115611e5357611e52611dbd565b5b611e5c82611dac565b9050602081019050919050565b82818337600083830152505050565b6000611e8b611e8684611e38565b611e1d565b905082815260208101848484011115611ea757611ea6611da7565b5b611eb2848285611e69565b509392505050565b600082601f830112611ecf57611ece611c8a565b5b8135611edf848260208601611e78565b91505092915050565b600060208284031215611efe57611efd611c80565b5b600082013567ffffffffffffffff811115611f1c57611f1b611c85565b5b611f2884828501611eba565b91505092915050565b60008115159050919050565b611f4681611f31565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611f86578082015181840152602081019050611f6b565b60008484015250505050565b6000611f9d82611f4c565b611fa78185611f57565b9350611fb7818560208601611f68565b611fc081611dac565b840191505092915050565b6000604082019050611fe06000830185611f3d565b8181036020830152611ff28184611f92565b90509392505050565b61200481611c42565b811461200f57600080fd5b50565b60008135905061202181611ffb565b92915050565b6000806000806080858703121561204157612040611c80565b5b600061204f87828801612012565b945050602061206087828801611d65565b935050604061207187828801611d65565b925050606061208287828801612012565b91505092959194509250565b61209781611d3c565b82525050565b60006020820190506120b2600083018461208e565b92915050565b6000602082840312156120ce576120cd611c80565b5b60006120dc84828501612012565b91505092915050565b600081600b0b9050919050565b6120fb816120e5565b811461210657600080fd5b50565b600081359050612118816120f2565b92915050565b6000806040838503121561213557612134611c80565b5b600061214385828601611d65565b925050602061215485828601612109565b9150509250929050565b600062ffffff82169050919050565b6121768161215e565b82525050565b6000602082019050612191600083018461216d565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b600381106121d7576121d6612197565b5b50565b60008190506121e8826121c6565b919050565b60006121f8826121da565b9050919050565b612208816121ed565b82525050565b600060208201905061222360008301846121ff565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600061226382611c42565b915061226e83611c42565b925082820190508082111561228657612285612229565b5b92915050565b60008151905061229b81611ffb565b92915050565b6000602082840312156122b7576122b6611c80565b5b60006122c58482850161228c565b91505092915050565b60006122d982611c42565b91506122e483611c42565b92508282039050818111156122fc576122fb612229565b5b92915050565b61230b81611d3c565b82525050565b61231a8161215e565b82525050565b61232981611c42565b82525050565b61233881611b79565b82525050565b610100820160008201516123556000850182612302565b5060208201516123686020850182612302565b50604082015161237b6040850182612311565b50606082015161238e6060850182612302565b5060808201516123a16080850182612320565b5060a08201516123b460a0850182612320565b5060c08201516123c760c0850182612320565b5060e08201516123da60e085018261232f565b50505050565b6000610100820190506123f6600083018461233e565b92915050565b6000604082019050612411600083018561208e565b61241e6020830184611c4c565b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061245f826120e5565b915061246a836120e5565b92508261247a57612479612425565b5b600160000383147fffffffffffffffffffffffffffffffffffffffff800000000000000000000000831416156124b3576124b2612229565b5b828205905092915050565b6124c7816120e5565b82525050565b60006060820190506124e2600083018661208e565b6124ef602083018561208e565b6124fc60408301846124be565b949350505050565b61250d81611f31565b811461251857600080fd5b50565b60008151905061252a81612504565b92915050565b60006020828403121561254657612545611c80565b5b60006125548482850161251b565b91505092915050565b6000604082019050612572600083018561208e565b61257f602083018461208e565b9392505050565b600081905092915050565b600061259c82611f4c565b6125a68185612586565b93506125b6818560208601611f68565b80840191505092915050565b60006125ce8284612591565b915081905092915050565b600082825260208201905092915050565b7f5341000000000000000000000000000000000000000000000000000000000000600082015250565b60006126206002836125d9565b915061262b826125ea565b602082019050919050565b6000602082019050818103600083015261264f81612613565b9050919050565b600061266182611bc5565b9050919050565b61267181612656565b82525050565b600060808201905061268c6000830187612668565b612699602083018661208e565b6126a660408301856124be565b81810360608301526126b88184611f92565b905095945050505050565b60006060820190506126d86000830186611c0a565b81810360208301526126ea8185611f92565b905081810360408301526126fe8184611f92565b9050949350505050565b600061271b61271684611e38565b611e1d565b90508281526020810184848401111561273757612736611da7565b5b612742848285611f68565b509392505050565b600082601f83011261275f5761275e611c8a565b5b815161276f848260208601612708565b91505092915050565b60006020828403121561278e5761278d611c80565b5b600082015167ffffffffffffffff8111156127ac576127ab611c85565b5b6127b88482850161274a565b91505092915050565b7f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00600082015250565b60006127f7601f836125d9565b9150612802826127c1565b602082019050919050565b60006020820190508181036000830152612826816127ea565b9050919050565b60006080820190506128426000830187612668565b61284f602083018661208e565b61285c604083018561208e565b818103606083015261286e8184611f92565b905095945050505050565b60008151905061288881611d4e565b92915050565b6000602082840312156128a4576128a3611c80565b5b60006128b284828501612879565b91505092915050565b6000819050919050565b6000819050919050565b60008160001b9050919050565b60006128f76128f26128ed846128bb565b6128cf565b6128c5565b9050919050565b612907816128dc565b82525050565b600060208201905061292260008301846128fe565b92915050565b600061293382611d3c565b9050919050565b61294381612928565b811461294e57600080fd5b50565b6000815190506129608161293a565b92915050565b60006020828403121561297c5761297b611c80565b5b600061298a84828501612951565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fdfea264697066735822122024cb6145830ca8621f9d328261efcb50568d2e47d0c9aefd1743371b8d5747b764736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 68,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 7989,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "cfaLib",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(InitData)367_storage"
      },
      {
        "astId": 8005,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_swapState",
        "offset": 0,
        "slot": "3",
        "type": "t_enum(SwapState)7949"
      },
      {
        "astId": 8012,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "lastTimeStamp",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 8014,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_swapperSwapAmount",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 8016,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_swapFrom",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 8018,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_swapTo",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 8020,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_swapTime",
        "offset": 0,
        "slot": "8",
        "type": "t_uint256"
      },
      {
        "astId": 8022,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_duration",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 8028,
        "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
        "label": "s_streamCreated",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_address,t_mapping(t_address,t_int96))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IConstantFlowAgreementV1)5062": {
        "encoding": "inplace",
        "label": "contract IConstantFlowAgreementV1",
        "numberOfBytes": "20"
      },
      "t_contract(ISuperfluid)7146": {
        "encoding": "inplace",
        "label": "contract ISuperfluid",
        "numberOfBytes": "20"
      },
      "t_enum(SwapState)7949": {
        "encoding": "inplace",
        "label": "enum SuperfluidStream.SwapState",
        "numberOfBytes": "1"
      },
      "t_int96": {
        "encoding": "inplace",
        "label": "int96",
        "numberOfBytes": "12"
      },
      "t_mapping(t_address,t_int96)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => int96)",
        "numberOfBytes": "32",
        "value": "t_int96"
      },
      "t_mapping(t_address,t_mapping(t_address,t_int96))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => int96))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_int96)"
      },
      "t_struct(InitData)367_storage": {
        "encoding": "inplace",
        "label": "struct CFAv1Library.InitData",
        "members": [
          {
            "astId": 363,
            "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
            "label": "host",
            "offset": 0,
            "slot": "0",
            "type": "t_contract(ISuperfluid)7146"
          },
          {
            "astId": 366,
            "contract": "contracts/SuperfluidStream.sol:SuperfluidStream",
            "label": "cfa",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(IConstantFlowAgreementV1)5062"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}